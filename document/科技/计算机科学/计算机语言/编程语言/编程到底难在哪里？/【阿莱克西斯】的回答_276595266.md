# 编程到底难在哪里？
- 点赞数：19522
- 更新时间：2019年12月25日01时01分30秒
- 回答url：https://www.zhihu.com/question/22508677/answer/276595266
<body>
 <p data-pid="Mw1ds_eS">这回答隔了数年被 <a class="member_mention" href="https://www.zhihu.com/people/e3f5794fa10022aa07c05b0b9e6dc537" data-hash="e3f5794fa10022aa07c05b0b9e6dc537" data-hovercard="p$b$e3f5794fa10022aa07c05b0b9e6dc537">@微调</a> 小姐姐点赞之后又引来了大量看热闹的观众和评论; (相比之下费劲精力写的专栏技术文章基本没人看真是惨)</p>
 <p data-pid="dqyAl590">想在这里统一回复一个关于认为做“最新东西”写的乱点没问题，反正最后会重构的问题；</p>
 <p data-pid="sZrMhLFU">这个理论对么？当然对，但是有一个前提，就是做的东西简单, 更确切的讲, 好测, 能很容易验证基本逻辑或者系统的normal path;</p>
 <p data-pid="6BO1j4WA">对于不好测，且出一个bug就影响重大, 可能会导致黄掉整个项目，那么程序复杂度就不能过于给系统添麻烦，程序复杂度和业务复杂度不成基本线性关系，说明这个程序员写程序没有scalability，做点简单东西还行，做复杂东西就原地爆炸；</p>
 <p data-pid="Z9VcI6RR">程序员产出的code能不能在复杂度这个维度上scale，是我想指出的东西；</p>
 <p data-pid="Q7YaVOGD">————————原文分割线————————</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="bSAiuxqG">记得之前组里来了一个美国实习生小伙子，很geek的那种，干活快，一天能给你写2000行代码(我code review的速度跟不上他写的速度)，让做什么东西，上午告诉做个这个功能，下午就能在测试环境跑起来演示了。跟他单独开会的时候，他说觉的普通的<b>编程没什么意思，太简单了</b>，写程序这方面已经没什么追求了，他比较想跟我研究大数据的框架，数据库，或者机器学习之类的工作，做设计，早日脱离代码这种无脑工作。</p>
 <p data-pid="lwKpA74f">我足足花了1周时间，每天review他的代码到凌晨。给他写的comments反馈快赶上我在知乎写的答案文章之和了。。。期间几小时几小时的开会论战，孩子狂，语速快，脑力灵，辩论角度刁钻。他天天要与我论战，看我的评语，速度还算慢下来了。</p>
 <p data-pid="buJAYGvA">没来得及讨论完，隔周我要休假了，2周。交代了些他要做的工作。</p>
 <p data-pid="Vqoq8vNe">2周回来，让他改的那个java包爆炸了，本来我们一个支持了7个功能的框架包，总代码量也就5k把，等我回来这包代码量1w5+。也就是说他为了一个小功能加了1w行代码。</p>
 <p data-pid="yETIEDIN">这没法review，只能跟他坐一块，先让他给我讲讲这代码都干什么的，然后他说：</p>
 <p data-pid="FrgpYtOy"><b>(沉思+100)这块我现在也看不太懂当时为什么这么写了。。。</b></p>
 <p data-pid="DWLIgu3t">(沉思)<b>这边写的比较复杂是因为当初那边是那样写的，所以这边没办法才只能这么写。</b></p>
 <p data-pid="hqBd20iu">(沉思)<b>把当初那边改好很麻烦，影响也很大，不如就这样吧。</b></p>
 <p data-pid="H3LPx2xH">(沉思)<b>这里这么写是因为你看着里是这样的， 然后这里有这个逻辑，然后这里。。。（来回来去翻n个类之后）。。。 所以你看我这里虽然写的比较诡异，但是完全没问题的！（得意ing）</b></p>
 <p data-pid="5bUvv6lc">(沉思)<b>这边做的这么奇怪是因为有个bug，通过这么写，这个就bug没了，我也不知道怎么回事。。。所以你看我在这边注释，这行不能删了。。。</b></p>
 <p data-pid="Htvl4dIz">(沉思)<b>我觉得这个功能很酷，你们虽然现在不需要，不过有总比没有好吧，将来如果……%¥……&amp;%&amp;……%*7&amp;%……*%…（我没听懂）的话，这个就很有用！！</b></p>
 <p data-pid="PodXi5IE"><b>... </b></p>
 <p data-pid="2CThEFqT">一次一次被我打回去重写，后来总算简化成大概5k行了；临走时候跟我说：<b>你这样编程也太难了。。。</b></p>
 <p data-pid="qDdpQ4K_">再后来由于一些额外复杂的代码造成我们实现新东西会很复杂，我又重写了一遍，总共大概不到1k行代码。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="rX_nsfAr">这里边有几件事情我想说：</p>
 <ol>
  <li data-pid="EIa0iK3f"><b>做出来容易， 做正确难</b>，这里做出来指没bug且完成需要的功能，这是最基本要求，不多加讨论。这里<b>正确，</b>不是指功能正确，而是指程序可以很容易推理理解，理解意图， 理解如何做到的，理解为什么系统不会出错。理解为什么要这么做。正确是<b>现在</b>怎么写不会挖坑害<b>将来</b>的人，<b>现在</b>怎么写能让别人<b>1年后</b>看你代码时候不可能理解错你现在的意图，<b>现在</b>怎么写能在别人<b>将来</b>犯错的时候提示他你错了。</li>
  <li data-pid="TfQ93OIa"><b>编程是给未来的未知人讲故事</b>，你无法知道将来这个人是谁，他都懂什么，他经历过什么，这个系统将来已经是什么样子了。我们需要在这种无知，缺乏信息的情况下做决定，从千万种把这件事做出来的方法里，选出你觉得最能把这个故事给讲好的那种方式，把故事写下来。<b>编程是一种沟通，沟通是一种艺术，用程序跨越时空之沟通则是一门属于程序员的特有的艺术</b>（就好比数学家用数学公式来沟通） coding is all about the art of communication（引用）。</li>
  <li data-pid="86m6cBJz">坏的决定会导致坏的决定，甚至导致人们去扭曲一个好的决定去迎合坏的决定。<b>垃圾会制造垃圾</b>，一个放在系统里不经清理的额外复杂度，会导致更多的额外复杂度的生成。</li>
  <li data-pid="EZxzYJ1d">每个人甚至同一个人的不同时刻都有自己的不同的制造额外复杂度的缺陷，比如我每年去看去年自己写的代码，觉得都是垃圾。</li>
 </ol>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="SwXsgmF2">然后我又想问几个问题：</p>
 <p data-pid="8ssdU23M">我们所在的部门，所在的组，公司，它们的文化，到底是关心作出了一个东西，还是关心做好了一个东西。一个总是给系统添加垃圾，留坑给后人，但是能很快做出能跑起来的系统的程序员，我们到底认为他是做了好事还是做了坏事？我们到底认为他很强，还是他很弱？用超过必要而为了突显技术实力（或者练手）的复杂工具，技术框架搭建系统，做完跑路，在一个组，一个部门，一个公司，那里的文化，到底应该是鼓励还是抑制这种行为？我们又应该如何在一个环境中，去倡导推崇什么样的文化，相遇什么样的人？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="T8PR6uNS"><b>人与文化，决定了什么人留在这里，什么人离开，什么人吸引什么人，什么人成长成什么样子。而设计／技术这些枝末细节则必顺应此中的人与文化而自然变化，或自愈，或走向毁灭；哪怕在恶劣的环境中，向下引导，向上规谏，潜移默化，最终改天换日，此为编程之大道也！</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gJNv_Yw2">下边是定理证明（雾） (￣∇￣)</p>
 <p data-pid="N3hO5-VZ"><b>最小垃圾存在定律</b>：定义垃圾为系统的总复杂度减去系统的本质复杂度；那么得到：如存在多种方法可以设计与实现一个系统或功能，存在且只存在一种实现会引入最少的垃圾；</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="l9kV8RJS"><b>垃圾与复杂度正比定律</b>：根据定义可得，系统存在的垃圾越多，系统越复杂；</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="aUZAfzDa"><b>垃圾倍增定律</b>：基于已有垃圾量a的现状来演化，进化此系统，增加的新垃圾量与已有垃圾量a成正比；</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="2xA-CGOl"><b>系统腐败定律</b>：当基于垃圾量a来实现新功能的cost大于新功能本身的价值时，系统腐败，需要重构；</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gsZZ3_fT"><b>战斗人员负战力定律</b>：如果程序员a引入的垃圾，在n次迭代中经过倍增所造成的成本，大于其所清扫的垃圾经过倍增所获得的机会成本，和其实现的新功能价值之和。此时，我们称此程序员战力为负值，其战力绝对值与其引入垃圾的能力和其清扫垃圾的能力的差值成正比</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="k9h_4Me-"><b>以一敌百存在定律</b>：由负战力定律可知，对所有的自然数n，一个正战力的战斗人员的战力 &gt; （负战力战斗员1+负战力战斗员2+ … 负战力战斗员n）的战力和</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="15nHVtG_"><b>系统本质复杂度不可知定律</b>与<b>系统表征复杂度无限接近本质定律</b>：取决于战斗人员的知识量，经验，天赋等，对于任何战斗人员n，都必定存在一个战斗人员m（考虑历史长河）使得战斗人员n观察系中的纯净无垃圾系统（复杂度总为1）是战斗人员m观察系中的含垃圾系统（复杂度为1+x），这使得在所有观察系中（包含外星生物），系统的表征复杂度(或者说观察复杂度)无限趋近与本质复杂度。然而我们只能通过观察来感知事物的本质复杂度，却永远无法得知我们离本质复杂度还有多远。（感谢评论区 <a class="member_mention" href="https://www.zhihu.com/people/d25b694fbf587c8bf8b8df4794145d72" data-hash="d25b694fbf587c8bf8b8df4794145d72" data-hovercard="p$b$d25b694fbf587c8bf8b8df4794145d72">@尤睿</a> 提出<b>表征复杂度</b>这个概念来纠正此定律）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Ujh71tOt"><b>以有限的生命去追求可以无限的提升的净化方法与视野，我们称之程序艺术家，也就是SDA（Software Development Artist）</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="LRWcRVwc">… it's extraordinarily important that we in computer science keep fun in computing…</p>
 <p data-pid="ZP4IB3ct">——— Alan J. Perlis (April 1, 1922-February 7, 1990) 《SICP》</p>
 <p data-pid="HzX6cUnx">打星际… 哦，不, 错了重来… 写程序，你快乐嘛？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="dj2mUtMz">写在最后，看到大家最关心的是他拿到正式录取资格了么？还有也许通过我的描述关于他的这个侧面，你会觉得他很不称职。其实不是的，他代码写的绝对是平均值往上的水平，他的问题在于：</p>
 <ol>
  <li data-pid="Q8RibV2I">是他根本没有想过去简化业务逻辑，所以很多符合最初需求的代码在简单优化业务逻辑之后完全不需要，</li>
  <li data-pid="N-hhzJiK">是自己加了很多功能，</li>
  <li data-pid="hYAdQakp">是自己加了很多自以为是的优化，比如用一个算法估算某个函数的输入数组的最大可能值，然后用那个值来初始化一个数组，因为这样就不会重新分配内存了（他原话）。</li>
  <li data-pid="rbXjhn3I">抽象能力有限，这个毕竟经验少， 年轻。</li>
  <li data-pid="7wOhxhHA">滥用设计模式(关于设计模式，最多程序员被绊住的一关：设计模式是面向对象编程模型中，应对经典问题的经典解决方案。这里就有两个问题，<b>第一，设计模式的场景用对了么</b>？<b>第二，为什么要用</b>面向对象<b>范式</b>，选择编程语言范式时，要从表达力最弱最简单的语言范式开始选择。这叫做<b>最弱表达力原则</b>，而面向对象范式作为最复杂，表达力最强的语言范式，在大多数时候都可以避免使用。关于第二点的论述证明，你可以看concept techniques and models of computer programming这本书。注意，这里说的是语言范式，而不是语言。即使你用java，如果你从来不使用mutable(专业词汇)的功能，和继承。那么你就没有使用面向对象范式)</li>
 </ol>
 <p data-pid="b8yeOD5G">他其实有非常强的解决问题的能力，想法天马行空，通过自己设计算法来猜函数可能需要的数组大小就可见一斑，还有一个从s3(专业词汇)读数据的需求，他不是简单调api完了，而是写了一个环状buffer(专业词汇)，使得网络，硬盘，app可以在理论上最大效率的适应程序当时的场景（为了协调异步，他自己发明了一个很笨拙的promise(专业词汇)），这非常厉害，一般的实习生哪怕sde1可能都写不出来（可惜的是场景会随业务逻辑激烈变化，今天的优化可以是明日的累赘，这就叫做过度优化，过度优化是一种强耦合，会把你的系统死死的钉死在当前版本）。他只是不明白简单是美这件事情而已。如果能有人帮他斧正，日后必成大器。</p>
 <p data-pid="40jEtXXC">他最终拿到了正式录取资格，这其中还有个小波折，终审的bar raiser(amazon内部的一个可以一票否决招聘结果的角色)看到他在代码复查系统里跟我的各种激辩，觉得这人不能留。好说歹说才给了正式录取资格。不过最后人家没接，去读博啦。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="X6GAE37F">最最后：在一个相对干净的环境写程序，不断找出新的本来以为不是垃圾的垃圾，对我来说，是一件非常愉快的事情。然而帮别人打扫他本就不该制造的垃圾则是非常痛苦的一件事。</p>
 <p data-pid="7J68EWKr">写程序，本应是多么快乐的一件事啊！</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="QrlgzHCZ">====== 小尾巴 =====</p>
 <p data-pid="l5O2EBi8"><a href="https://zhuanlan.zhihu.com/c_158208519" class="internal">用谁都能看懂的方法解释分布式系统</a></p>
 <p data-pid="GVXecW50"><a href="https://zhuanlan.zhihu.com/c_212000558" class="internal">一个书魔程序员的读书简评</a></p>
 <p data-pid="5OwPRzbc"><a href="https://www.zhihu.com/question/22508677/answer/276595266" class="internal">编程到底难在哪里？www.zhihu.com</a></p>
 <p data-pid="74F50kvY"><a href="https://www.zhihu.com/question/68611994/answer/298845862" class="internal">在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进？www.zhihu.com</a></p>
 <p data-pid="FXCEzPoO"><a href="https://www.zhihu.com/question/275845393/answer/397349131" class="internal">请问分布式事务一致性与raft或paxos协议解决的一致性问题是同一回事吗？www.zhihu.com</a></p>
</body>