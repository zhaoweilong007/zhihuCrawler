# PHP、Java、Python、C、C++ 这几种编程语言都各有什么特点或优点？
- 点赞数：6249
- 更新时间：2020年01月05日13时51分15秒
- 回答url：https://www.zhihu.com/question/25038841/answer/77113390
<body>
 <p data-pid="N1FIYXtL">相信每一个计算机科班出身的同学或许都有这样的经历：在大三的某一天，仿佛打通了全身筋脉一般把三年的所学：“数电里的与非门——计算机体系结构——汇编语言——C语言——C＋＋语言——Java语言”。所有知识全部串联了起来。所有这些语言的出现都仿佛都有了必然性和追根溯源的历史感。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="wxmEdFGo">**阅读指引**</p>
 <p data-pid="hpbqj7za">读懂此文，需要以下基础:</p>
 <p data-pid="xXwTRde3">1. 至少写过50000行的代码;</p>
 <p data-pid="rkYWX6_X">2. 汇编基础（静态数据段，代码段，堆栈段）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="SgKNMKI5">有以下或者类似知识就更好了：</p>
 <p data-pid="xjEbBjQn">1. C语言编译，C++对象模型，MFC反射的实现</p>
 <p data-pid="g6Ju1E-e">2. JAVA的解释器运行原理</p>
 <p data-pid="Drzew3-P">3. 使用过javascript，Python，PHP：感受过代码和类型系统在运行时的自由程度的不同</p>
 <p data-pid="qAdQlXdg">4. 计算机组成原理</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="k6jkauE_">**序 —— 一些问题**</p>
 <p data-pid="XP7gqH6j">1. 程序设计语言的目的是什么？</p>
 <p data-pid="6w4ajHoC">2. 为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统、一个自动打车APP）</p>
 <p data-pid="dn3-pmrS">3. 为什么类型申明在C语言中要与控制流隔离开来?</p>
 <p data-pid="ljmePGq3">4. 现在主流语言最基本的元素是？</p>
 <p data-pid="iVrmQdw9">5. 有没有语言它的类型结构，在运行时也可以改变？</p>
 <p data-pid="afvERTf6">动态性？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Em2mthaR">什么是动态性？</p>
 <p data-pid="RkZBryjT">1. 编译后确定了什么信息，之后不再改变；</p>
 <p data-pid="9ZDKM0kD">2. 运行时可以改变、添加什么；</p>
 <p data-pid="MpE7q-Ab">3. 运行时是否保存着类型信息。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="0Dai2Pp7">程序中的信息分为几类？</p>
 <p data-pid="oXA451li">1. 数据信息</p>
 <p data-pid="pg3w5Wkf">a) 编译时Meta-Data元数据（类型框架、空间占用）</p>
 <p data-pid="Z4wydRWe">b) 运行时Meta-Data元数据（继承体系、用于new或者反射）（特别区别编译与运行的Meta-Data的不同。）</p>
 <p data-pid="-shHPWCJ">c) 堆栈段中地址偏移（C++的switch case中不能声明变量、共享内存）</p>
 <p data-pid="bphFmf1A">d) 静态段中地址</p>
 <p data-pid="AJNiDzRT">2. 指令信息</p>
 <p data-pid="tPsRZ3_7">a) 代码段（动态性需要操作系统或者虚拟机支持，例如动态链接库，动态类加载，lisp语言自生成代码）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="6BOcj_Jy">**语言举例**</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="TedrpRv3">**汇编语言**</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="CjXxomTT">汇编语言没有动态性吗？</p>
 <p data-pid="9sEdCgou">没有。首先，寄存器、数据段、堆栈、代码段完全由程序员控制。完完全全是写死了的。然后，根据冯诺伊曼机的规则；取指令，执行，取指令，执行……</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="npJM3UrC">既然都有数据段了，还要堆栈段来做什么？这不是多余？</p>
 <p data-pid="t_PqxrK4">一开始本没有堆栈，直到60年代出现了module模块化，才有了堆栈。汇编中的模块叫子程序，不过仍旧靠程序员全权控制。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="n0J4meqz">堆栈和模块化的优点有？</p>
 <p data-pid="yuHcYq6g">1. 递归</p>
 <p data-pid="3jqvPdpa">2. 功能分离到模块，可复用</p>
 <p data-pid="Pdi2HlLK">3. 封装作用域</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="hVM4NxAg">堆栈和模块化的缺点有？</p>
 <p data-pid="wDnWKI5S">1. 时间上：保存现场、还原现场的代价（另，高级语言编译“消除尾递归”节约部分成本）</p>
 <p data-pid="RoYM_yWC">2. 空间上：爆栈的危险</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="40HKdoX4">**C语言**</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="rFNRv2kB">C语言比起汇编多了什么东西？</p>
 <p data-pid="WeC2K_l4">1. 编译器</p>
 <p data-pid="UssXa0aW">2. 表达式（相比汇编，可以处理多个操作数了。）</p>
 <p data-pid="theUXcZ-">3. 函数与模块｛｝（真·模块化，栈操作无需程序员完成）</p>
 <p data-pid="nvLnbr71">4. 类型（原子类型、结构类型、数组、指针）</p>
 <p data-pid="9gWUrv6_">5. 头文件，库</p>
 <p data-pid="re2mA3b_">总之，C语言并没有比汇编多了新的特性，它只是把汇编的繁琐操作抽象出来，让编译器完成，减轻程序员负担。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="UiCbPnr_">编译器的作用是？</p>
 <p data-pid="0Cuwt3Nf">（减少程序员负担）</p>
 <p data-pid="aD4Wu-TO">1. 解析表达式，控制流（汇编中指令只有1-3个操作数，而表达式可以多个操作数）</p>
 <p data-pid="yNk-AfwV">2. 模块和函数的抽象（完成堆栈中保存恢复现场的工作）</p>
 <p data-pid="MOIoVl4I">3. 类型变量的管理（所有变量被替换成直接访问的地址，最快的访问速率）</p>
 <p data-pid="2aQ9pYYh">4. 代码优化</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="8ycrrRmB">变量是替换成可以直接访问地址的？</p>
 <p data-pid="_Wp9exj3">a) 编译时的Meta-Data（struct的成员，数组的长度，以便替换到指令流；只在编译器中维护，编译结束后丢弃）</p>
 <p data-pid="MZOaIhuV">b) 计算出每个变量相对于该模块的偏移（一旦算出该偏移地址，将固定在执行码中，无法改变；就是说编译完成后，所有变量的偏移地址都固定下来了。）</p>
 <p data-pid="ETblsJ_N">c) 对变量的存储进行管理（所有的变量/内存地址的布置，都是在编译时确定的；也就是说，可执行码中没有类型信息，只有地址，任何数据都是地址来操作，完全和汇编类似。至于寄存器的安排，那是更下一层的类似缓存策略算法的结果。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="PNr9zEgo">编译出来的执行码与汇编的执行码有特征的区别吗？</p>
 <p data-pid="Yq-2E0UR">没有。特别是在编译器优化之后。</p>
 <p data-pid="MlJb3Ztf">无法通过执行码，区分汇编和C程序。</p>
 <p data-pid="tO0FESUh">打个比方，一只“程序猫”在黑笼子里，在里面喵喵的叫，无法通过它的叫声来判断它是“汇编猫”还是“C语言猫”。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gICQ4t4p">从效率上来讲，C的多余代价在哪里？</p>
 <p data-pid="MR4aFHzQ">1. 编译的时间</p>
 <p data-pid="XUuLfVJa">2. 模块的堆栈操作</p>
 <p data-pid="-S6QkUtn">总之，经过优化的C程序执行码与汇编效率几乎相同。</p>
 <p data-pid="L8XvAQSK">因为从理论上来说，C并没有引入运行时的新机制。</p>
 <p data-pid="IfvDuTNk">我理解的C语言只是一种汇编的宏而已。</p>
 <p data-pid="QVuCHgi2">**C++语言**</p>
 <p data-pid="mTop2Zln">（推荐《深度探索C++对象模型》）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="2oDcfs42">C++语言比C语言多了什么？</p>
 <p data-pid="R6xgMYGf">1. 成员函数</p>
 <p data-pid="YtlSrnRC">2. 类型继承体系</p>
 <p data-pid="8IcGI6R8">3. 虚函数、虚继承</p>
 <p data-pid="pWUSnyM8">4. 模板</p>
 <p data-pid="dhJhvhpv">5. 涉及到了多种编程范式</p>
 <p data-pid="MgNY5hMc">（开始更抽象，语言逐渐开始脱离冯氏结构。）</p>
 <p data-pid="D5GU2Hqh">其中，面向对象的思想，让程序与现实事物的关系更加紧密。</p>
 <p data-pid="XA7Sfr2p">程序设计的负担，也因为OO与设计模式的流行，而变得轻松。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="OeR-NWHV">编程范式是什么？</p>
 <p data-pid="SppMi7ds">就是一套指导思想行为准则。</p>
 <p data-pid="KjPtIYBL">（例如，C是过程式，Haskell是函数式，JAVA是面向对象，Python是简单的大杂烩，shell是调用命令的，lua是调用c程序的，PHP是写页面的，ProLog是线性逻辑推理的。</p>
 <p data-pid="hqwpBQDV">再例如，UML是描述规格specification的，XML是存储数据的。</p>
 <p data-pid="kA8HWCwf">再再例如，CSS是描述网页表现的，HTML是描述网页内容的。</p>
 <p data-pid="gB0vYQ84">javascript比较神奇，不敢说。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="2mhDTO8b">C++有什么编程范式？</p>
 <p data-pid="pZus5ugb">1. 过程式（使用STL的类C语言编程）</p>
 <p data-pid="nCCGYwn4">2. ADT式（自定义抽象数据类型，继承；但是不用new，不用virtual；拷贝构造；为了防止资源泄漏，也发明了RAII的方式进行资源的初始化和释放）</p>
 <p data-pid="TGjuRnnp">3. 面向对象式（使用new，使用virtual，需要指针或引用；实现多态。）</p>
 <p data-pid="FhCqnS9W">4. 泛型编程（《Modern C++ Design》各种奇淫技巧，业务层代码比较少遇到）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="zCtVB_SA">C++编译器是怎样实现的？</p>
 <p data-pid="XZOjxA5m">C++开始有一个叫做cfront的编译器，即把C++语言先翻译成C语言。</p>
 <p data-pid="UO2p65av">然后再用C编译器来编译，C的编译器并不知道此段代码是来自C++还是C。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="pPl4ATyY">C++语言特性分别是怎样实现？简单说。</p>
 <p data-pid="PNqvROPj">1. 成员变量：和C语言的struct 类似，最后也会被直接替换成地址，便于高效访问。</p>
 <p data-pid="VvNX6P6w">2. 成员函数：使用特殊函数名编码方案，翻译成C函数，并添加this指针作参数。（如___clsA12345func001(...,clsA *this)）</p>
 <p data-pid="SGbMZ1nV">3. 类型继承体系：通过C++编译时的Meta-Data来实现。即在编译时，编译器是知道类型信息与继承体系的，但是编译成C语言后就丧失了此类型信息。</p>
 <p data-pid="-1bWn1I1">4. 虚函数、虚继承：为了支持多态，这也是“面向对象”最重要的特性，使用了虚函数表和虚基类表。注意，运行时多态是通过运行时查表实现的。稍后详细说。</p>
 <p data-pid="jWG5LbpC">5. 模板：通过代码复制的方式实现。每次编译都需要重新编译，不能编成库文件直接使用。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ucjKAeqz">C++编译器的准则与virtual机制？</p>
 <p data-pid="BQvHYsa7">1. 首先，C++的编译准则，希望做到与C一样的效率。希望做到以下：</p>
 <p data-pid="ax_O3WG3">——a) 没有运行时调用间接性。任何数据在运行时都是一个地址直接就访问到。</p>
 <p data-pid="u6A3jkHS">——b) 没有运行时的Meta-Data。无需通过Meta-Data来访问某个复杂的类层次。</p>
 <p data-pid="IL8Gn8KV">——c) 所有的数据都希望用C中struct来实现，即在编译时就确定好对象及其成员地址。</p>
 <p data-pid="9ABKgQ88">2. 以上，在过程式范式，与ADT范式中都是成立的。</p>
 <p data-pid="OBQlItne">3. 但是，在面向对象范式中，渴望做到：</p>
 <p data-pid="Zf26KWAc">**需要维系着同一个继承体系成员结构的一致性，只有这样，才能保证运行时的多态性。即希望通过同一个入口，访问到父类或者子类的相同数据成员、函数成员，而不在乎具体对象的是父类还是子类。**</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="e_VEfO2Q">C++的virtual机制如何实现的？</p>
 <p data-pid="E4xo8lB3">a) 虚函数</p>
 <p data-pid="oVVXPSUl">i. 虚函数，运行时，每个有虚函数的类型（哪怕是子类）都维持着一个虚函数表，这已经是运行时的Meta-Data，通过查表，即可找到对象自己的虚函数。</p>
 <p data-pid="TwOgHUIL">ii. 例如clone肯定是object.__vptr__Base-&gt;#3()，无论具体的对象。</p>
 <p data-pid="EG9Czu7i">b) 多重继承</p>
 <p data-pid="RXfikA_M">——如何处理后继的base基类？由编译器判断指针类型并加上相应的偏移。</p>
 <p data-pid="hMURnvVe">c) 虚继承</p>
 <p data-pid="J0Jz37ix">——添加一个虚基类指针，指向共享部分。</p>
 <p data-pid="lyvyCPoG">这样的缺点有两个：</p>
 <p data-pid="CJOsAlLa">1. 虚基类的子类都要背负一个基类指针指向共享部分。如果继承了多个虚基类，还需要多个这样的指针。（Microsoft的解决方法是增加一个虚基类表，类似于虚函数表。）</p>
 <p data-pid="2f0_63u5">2. 虚继承链条的增加，会导致间接访问的层次增加。例如两个菱形继承的串联。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="mIntFxWZ">跨平台的级别有哪些级别？——头文件，库，源代码</p>
 <p data-pid="OIWS_B1n">1. C++确实在源代码的层次是可能跨平台的（例如《POSA2》中加了针对不同平台的各种宏的代码）。</p>
 <p data-pid="KXRlJhEe">2. 也可以通过相同的头文件去访问不同平台的库。</p>
 <p data-pid="I2Koo_zZ">3. 但是，不同操作系统中的不同的API大大增加了跨平台的难度。</p>
 <p data-pid="n5eyl1xL">4. 跨平台的责任留给了程序员（充斥着大量宏的C++跨平台代码确实让人头疼。）</p>
 <p data-pid="ASSCJxoA">5. 编译器面对不同的系统也不敢作为，它只是负责编译源代码，链接。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="nAm1B2HX">如何使用C++才能保证其高效性能？</p>
 <p data-pid="5abUimAw">1. 有额外负担的机制：虚函数，虚继承，拷贝构造。</p>
 <p data-pid="cN2gpYr7">2. 用一次虚函数，多了一次指针寻址的效率损失，并且相对于inline内联（另，inline是编译器优化的重头），还损失了保存和恢复现场的效率。</p>
 <p data-pid="mcMCPEx2">3. 用一次虚继承，也多一次指针寻址的效率损失。（另，虚基类没有成员变量没有虚函数的时候会被优化。这也是JAVA可以多重继承接口interface的原因。）</p>
 <p data-pid="hy0wKppM">4. 不要使用virtual在复杂的多继承，深层次继承中。</p>
 <p data-pid="gQNnH6Ct">5. 编译速度会较慢：virtual机制会使编译器处理更多的Meta-Data。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="xKIp4ytA">**JAVA语言**</p>
 <p data-pid="vCsD_Mzh">（推荐《本地Java代码的静态编译和动态编译问题》）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="IZq3rj39">JAVA语言比C++语言多了什么？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="MM7xOhX3">1. 虚拟机</p>
 <p data-pid="HLUXXxBf">a) 跨平台</p>
 <p data-pid="v83vwb_G">b) 动态编译</p>
 <p data-pid="d9Q2hDde">c) 动态特性</p>
 <p data-pid="5kvgGJZ8">2. 没有指针</p>
 <p data-pid="FhdyuaPw">3. 没有类的多继承，有接口的多继承。</p>
 <p data-pid="_6nOI4fc">4. 统一的库</p>
 <p data-pid="O-X4OeTj">从编译来说，JAVA比C++迈出了一大步。</p>
 <p data-pid="9g08CZBt">它的跨平台特性和运行时的灵活性，为JAVA自己以及未来语言都提供了很多可能性。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="pNrgOMhk">虚拟机的好处有什么？</p>
 <p data-pid="HPvBcdsd">1. 跨平台：在OS与字节码间隔了一层。实现了程序员无负担的跨平台。</p>
 <p data-pid="vAUlr7Ja">2. 动态编译：许多信息不必在编译后确定，为动态特性提供可能，稍后详细说。</p>
 <p data-pid="WazXdNpJ">3. 运行时维护着类型信息，甚至可以加载新的类型。（CORBRA依赖这个实现）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="nNEwzHUd">JAVA编译执行的过程是怎样的？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="_-IXLiw1">1. 编译后产生一个基于堆栈的字节码。</p>
 <p data-pid="7GvyuCcp">2. JRE在不同的OS上提供支持。</p>
 <p data-pid="3tcziDxU">3. 起初的JRE是解释执行的，效率低下。</p>
 <p data-pid="9APuAe0C">a) 获取待执行的下一个字节码。</p>
 <p data-pid="3zx8x681">b) 解码。</p>
 <p data-pid="zKAn6g-v">c) 从操作数堆栈获取所需的操作数。</p>
 <p data-pid="oy6JJYYa">d) 按照 JVM 规范执行操作。</p>
 <p data-pid="xD2AeqEE">e) 将结果写回堆栈。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="MOPqSgra">JAVA是如何解决执行效率低下的问题呢？</p>
 <p data-pid="mISHfygs">使用JIT（Just-in-time）编译器进行动态编译。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="0XwKCNX9">JIT（Just-in-time）是怎样运行的呢？如何解决了效率的问题？</p>
 <p data-pid="ZYL4D6_b">如上图：</p>
 <p data-pid="0BkmAzO3">1. 每次按照一个function来编译。转成中间表示，并优化其效率，再生成可执行码。</p>
 <p data-pid="JdRCrXY9">2. 编译器的编译线程和执行线程是分开的，应用程序不会等待编译的执行。</p>
 <p data-pid="j8k0Dc1T">3. 分析框架Profiler会观察程序行为，对频繁执行的function进一步优化。（例如function内部对象维持一个池不必每次生成。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Y1g3bd-a">动态编译的优点有什么？</p>
 <p data-pid="o5NIGBBU">可以根据程序的行为，优化其代码</p>
 <p data-pid="C6H2d62-">1. 例如频繁执行的function——热方法</p>
 <p data-pid="gb-fYArE">2. 例如arrayCopy方法，如果每次都拷贝大段内存，在指令集中有特别指令可以加速。</p>
 <p data-pid="SZLu7oEq">3. 例如类层次结构，多态的优化。（大多数虚调用都有其固定的一个目标，JIT因此生成的直接调用代码比虚表调用代码的效率会更高。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="TtDQpfiT">动态编译的缺点有什么？</p>
 <p data-pid="yOnghh44">1. 大量的初始编译会影响程序启动时间。</p>
 <p data-pid="JR0-U1Fv">2. 运行时候的编译，行为分析都需要花费时间。</p>
 <p data-pid="QJ_XdPKa">3. 运行效率达到稳定需要时间。</p>
 <p data-pid="3n0gJ9i6">4. 实时GUI型的程序不能忍受“动态编译”和“GC”带来的延迟。</p>
 <p data-pid="IbGzNxg-">JAVA如何解决实时的需求？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="45OyoDkg">使用AOT（Ahead-of-time）编译器：预先编译成为可执行码。</p>
 <p data-pid="ZemyH7ee">AOT（Ahead-of-time）的缺点:</p>
 <p data-pid="FYTJZNwR">对于一些动态特性的支持效率低下</p>
 <p data-pid="A0LAvalO">1. 反射机制</p>
 <p data-pid="aKgzCbaF">2. 运行时类加载</p>
 <p data-pid="E7VUkGya">JIT与AOT的对比</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="c3Nctb-Z">总体来说，JAVA适合怎样的应用呢？</p>
 <p data-pid="_f7a4SYR">JAVA比较时候需要长期运行的应用，例如Web服务器，Daemon服务。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ahiSe-D7">**函数式语言**</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="4G-ZiQs7">函数式语言通常有哪些呢？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="P8KNYF8k">1. 函数式语言</p>
 <p data-pid="WXkF2aKd">a) Lisp</p>
 <p data-pid="w5h0YZbF">b) Scheme</p>
 <p data-pid="oPjECe39">c) Haskell（纯函数式）</p>
 <p data-pid="KwOtsOhb">d) F#？</p>
 <p data-pid="Zsswz3Qv">2. 包含了函数式特性的语言</p>
 <p data-pid="luC5wZKE">a) Python</p>
 <p data-pid="l-Hj8egt">b) Javascript</p>
 <p data-pid="LsfvPQfl">c) JAVA</p>
 <p data-pid="NU59hy0s">d) C?</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="GRh69amI">函数式语言有哪些特性？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="NUiTeA3f">1. 函数无副作用，只对输入输出有作用</p>
 <p data-pid="LgC6NOBC">2. 高阶函数，lamda演算。(这个像C函数指针，但是它是高阶的，即返回值可能也是函数)</p>
 <p data-pid="dB7elsyh">3. 没有过程，类似规格说明的语法，更容易理解，自解释。</p>
 <p data-pid="LLv_GuGj">4. 基于list的编程，函数更通用。</p>
 <p data-pid="uX-RNvnS">5. 惰性计算（这个很像“树形DP”）</p>
 <p data-pid="39eqIZQ8">6. 有对应的数学形式化表达，有可能证明其正确性。（最终目标可能是保证程序没有bug。）</p>
 <p data-pid="RY8-xAg_">7. 其模型适合多核或者分布式的计算。</p>
 <p data-pid="jcNZoxqw">a) 不变性（immutable）</p>
 <p data-pid="JG07W6kY">b) 惰性计算/按需计算（lazy evaluation）</p>
 <p data-pid="-QP2aYGi">c) **最重要的是，由于函数式语言不可在同一数据上做修改，每一次运用一个函数都会在新的位置产生新的数据，这与过程式语言在同一位置对数据做多次操作不同：函数式语言的函数依赖于前一次函数产生的结果数据，过程式语言依赖于数据的位置。这里函数式语言就暗含了计算的依赖顺序，如果没有前后顺序关系，就可以并发。而过程式语言没有指定这个顺序，就需要通过加锁、Actor、Channel等模式来指定这个顺序**</p>
 <p data-pid="e7w3Nz9n">总的来说，函数式语言，向着更抽象迈了一大步，更像是数学上的表达，几乎与冯诺伊曼体系断绝了关系。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ou1XMjg0">函数式语言的劣势？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="8MyaWNkS">1. 效率不高（因为其抽象，远离了冯诺伊曼体系）</p>
 <p data-pid="IQf-XTBt">2. 平台以及开发环境都比较简单。</p>
 <p data-pid="ZRrhG3sw">3. 缺少推广，应用不广泛</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="qrJcMyDC">**逻辑程序设计**</p>
 <p data-pid="yRUnMBAb">ProLog语言，线性逻辑。人工智能语言。没有接触过。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="04UY-TQr">**总结**</p>
 <p data-pid="E9IboMQI">动态性有哪些呢？</p>
 <p data-pid="1ma9J9Jr">1. 多态性：运行时根据具体对象来访问属于它的方法。（而不理会指针的类型。）</p>
 <p data-pid="--sgITNr">2. 反射：运行时维系着类型结构的Meta-Data。</p>
 <p data-pid="X66O2axX">3. 运行时类加载：运行后再次加载新的数据类型和指令流。</p>
 <p data-pid="mcGDOBjx">4. 动态链接：OS根据按需链接库文件。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="5j5XaoPE">编译语言 和 解释语言 的分界在哪里？</p>
 <p data-pid="yuntNc6a">语言本身并没有编译类型或者解释类型。（例如：JAVA也可以静态编译后成可执行码。）只有少数运行时特性是依赖于解释型的。（可能需要运行环境的支持。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="s_XiEl01">为什么解释语言都需要虚拟机或者运行环境支持？</p>
 <p data-pid="m91uBing">动态编译，运行时Meta-Data的保存，这些功能对于每个程序都是一致的。</p>
 <p data-pid="Mv5o9lAu">所以把它们分离开来，不必每个程序植入这些代码</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="I3mPPpan">非脚本语言 和 脚本语言</p>
 <p data-pid="k_lDpnyo">脚本语言，我理解是负责调度其他代码的语言。</p>
 <p data-pid="AAQFxTyF">例如shell脚本（调用命令），lua（调用C）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="QbH6ec45">跨平台分为哪些层次？</p>
 <p data-pid="Q4zehA01">1. 源码跨平台（C，C++，但是因为系统调用接口不同，程序员负担太大，但是汇编却不是。）</p>
 <p data-pid="GbDuX_NV">2. 执行码跨平台（JAVA，有些语言直接从源码解释执行，例如Javascript，PHP）</p>
 <p data-pid="YOabX2Vc">发展历史（推荐《近看图灵碗 (一. 从苏黎世到巴黎)》）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="KScVFxWb">学术上有哪些实验性语言？</p>
 <p data-pid="Rg7gi3En">1. Fortran</p>
 <p data-pid="vYfvZX2D">2. ALGOL58</p>
 <p data-pid="kai-5HSu">3. ALGOL60</p>
 <p data-pid="RPGM0wK9">4. Lisp</p>
 <p data-pid="Bm6PlwXz">5. smalltalk</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="1lRiHxuV">常用语言</p>
 <p data-pid="cA17oHWl">过程式：C，ALGOL，Pascal，</p>
 <p data-pid="bUXNdweh">面向对象式：C++，smalltalk，JAVA，Delphi</p>
 <p data-pid="AeN780-T">函数式：Lisp，Scheme，Haskell，</p>
 <p data-pid="FnIBJpm2">逻辑式：Prolog</p>
 <p data-pid="fcc_4RH0">脚本？PHP，Python，Ruby</p>
 <p data-pid="jWl1bhke">存储描述信息：XML，CSS，HTML</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="8BC4oRlA">**回答问题**</p>
 <p data-pid="bCrDsgoe">程序设计语言的目的是什么？</p>
 <p data-pid="zoSCtpT_">1. 控制数据</p>
 <p data-pid="Ib2W6sQO">2. 控制指令流</p>
 <p data-pid="j3itLF4K">为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统。）</p>
 <p data-pid="xCWwoQ5-">逐行执行，很大程度是起源于冯诺依曼体系结构。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="VJ-r4zhb">为什么类型申明在C语言中要与控制流隔离开来?</p>
 <p data-pid="gXsireHq">因为在编译时，具体的类型信息，要转化成地址偏移，然后替换控制流中的类型变量。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="JEx87PUA">现在主流语言最基本的元素是？</p>
 <p data-pid="jKAAuUgN">控制流 与 类型系统。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="5KUVAxna">有没有语言它的类型结构，在运行时也可以改变？</p>
 <p data-pid="5TmMuQTX">Javascript只有对象没有类，使用prototype的方式继承，运行时给某个对象添加新的数据成员。没有类型体系。</p>
 <p data-pid="hjutTyrf">许多后来的语言在运行时都保存着类型信息的，例如Python，JAVA。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="1vHbUypp">**综上所述**</p>
 <p data-pid="9YiYP80C">控制流——指令流</p>
 <p data-pid="Og6cdhzx">类型系统——为了计算出变量地址信息</p>
 <p data-pid="h7G7WJLd">区分运行时的Meta-Data与编译时的Meta-Data</p>
 <p></p>
 <p></p>
</body>