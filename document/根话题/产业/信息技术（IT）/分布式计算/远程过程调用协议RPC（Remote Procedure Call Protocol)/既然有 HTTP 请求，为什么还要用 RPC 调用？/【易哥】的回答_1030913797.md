# 既然有 HTTP 请求，为什么还要用 RPC 调用？
- 点赞数：5107
- 更新时间：2022年06月18日16时21分14秒
- 回答url：https://www.zhihu.com/question/41609070/answer/1030913797
<body>
 <p data-pid="uqBo3-Yx">首先，实名赞扬题主的问题。<b>这个问题非常好</b>。</p>
 <p data-pid="WQLQqKvp">但是，该提问也确实有点问题：<b>HTTP和RPC不是对等的概念</b>。</p>
 <p data-pid="2K4VTH1c"><b>RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。</b></p>
 <p data-pid="QZUe4mm6">而<b>HTTP只是一个通信协议，工作在OSI的第七层</b>，不是一个完整的远程调用方案。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Ad4nbBlw">所以，要想回答这个问题，应该拉平为一个对等的概念。例如，<b>HTTP+Restful规范+序列化与反序列化</b>，构成一个完整的远程调用方案，再和<b>RPC</b>进行比较。而<b>单纯的HTTP，只是一个通信协议，自然无法和RPC比较</b>。</p>
 <p data-pid="SKI7TXDL">这就像是牛（HTTP）不能和马车（RPC）比较。要想比较，就应该将牛补齐为牛车，然后和马车比较。</p>
 <p data-pid="qOOdEMs6">感觉题主应该是问：<b>基于HTTP的远程调用方案（包含了接口规范、序列化反序列化等） 和 使用RPC的远程调用方案 有什么不同。有了前者，为什么还要有后者。</b></p>
 <p data-pid="Rx50FLtc">下面我们来解答这个问题。</p>
 <hr>
 <p data-pid="e6O1U9Lz">我们先介绍基于HTTP的远程调用方案。</p>
 <p data-pid="3fMKL6p7">HTTP+Restful，其优势很大。它<b>可读性好</b>，且<b>可以得到防火墙的支持、跨语言的支持</b>。而且，在近几年的报告中，Restful<b>大有超过RPC的趋势</b>。</p>
 <p data-pid="_AT8nF5V">但是使用该方案也有其缺点，这是与其优点相对应的：</p>
 <ul>
  <li data-pid="AMjKPm2I">首先是<b>有用信息占比少</b>，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。</li>
  <li data-pid="zm3lbFcf">其次是<b>效率低</b>，还是因为第七层的缘故，必须按照HTTP协议进行层层封装。</li>
  <li data-pid="XI4jPBw3">还有，其<b>可读性似乎没有必要</b>，因为我们可以引入网关增加可读性。</li>
  <li data-pid="BAgd-R41">此外，使用HTTP协议<b>调用远程方法比较复杂</b>，要封装各种参数名和参数值。</li>
 </ul>
 <p data-pid="JzYeReLt">而RPC则与HTTP互补，我们详细介绍下。</p>
 <p data-pid="Yo75gvVr">看完这篇回答，<b>能让你对RPC的产生、原理、实现代码都有着清晰的了解</b>。这样，也能在业务系统中，在RPC和HTTP之间做好抉择。</p>
 <p data-pid="YpoAK2eO">但需要再说一句，不是说RPC好，也不是说HTTP好，<b>两者各有千秋，还在比拼中</b>。</p>
 <p data-pid="Toe7_GgU">要问我站谁？我<b>根据业务场景，灵活站位……</b></p>
 <hr>
 <p data-pid="gaamIQOw">评论区产生了一些争论，我在这里统一进行说明。争论主要发生在两点：</p>
 <p data-pid="XJF4eNXZ">1、<b>HTTP和RPC同一级别，还是被RPC包含？</b></p>
 <p data-pid="1XkCalQd">2、<b>Restful也属于RPC么？</b></p>
 <p data-pid="ZN6yTopy">对于以上两点，我画图来一一说明。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-f79abd8e489337fafc7aafe75799b599_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="718" data-rawheight="515" data-original-token="v2-fd398b078624779251793c6b91d092b7" data-default-watermark-src="https://pic1.zhimg.com/50/v2-8918e0a5be71fdc50830a166064860e9_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic1.zhimg.com/v2-f79abd8e489337fafc7aafe75799b599_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="F2pXgTf1">上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。其中一个是和RPC并列的，都是跨应用调用方法的解决方案；另一个则是被RPC包含的，是RPC通信过程的可选协议之一。</p>
 <p data-pid="gDZQ3WGk">因此，<b>第一个问题的答案是都对。看指的是哪一个蓝色框。</b>从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。所以，题主所述的HTTP请求应该是指：基于HTTP的远程调用方案（包含了接口规范、序列化反序列化等）。这样，它才是和RPC同一级别的概念。</p>
 <p data-pid="kpeAT2AF">第二个问题是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。</p>
 <p data-pid="KMOM6gPx">RPC字面理解是远程过程调用，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。</p>
 <p data-pid="6mEc2CrE">但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。</p>
 <p data-pid="2BOuP4R-">因此，<b>第二个问题的答案是Restful不属于RPC，除非对RPC有着非常规的宽泛理解。</b></p>
 <hr>
 <p data-pid="ELmTDfjF">RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。</p>
 <p data-pid="AbUbXGWi">要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-a5d8d1ec94bc8726faa23902b1507acf_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="416" data-rawheight="93" data-original-token="v2-e9f5cc5b91d28c8948d771b4013f39ed" data-default-watermark-src="https://pic1.zhimg.com/50/v2-f55911c65209142b9b58acab178ffe2a_720w.jpg?source=1940ef5c" class="content_image" width="416">
 </figure>
 <p data-pid="F2BeLP51">而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。</p>
 <p data-pid="IX6Rn0-W">要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。</p>
 <p data-pid="iFvw4tb3">然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p>
 <p data-pid="7zEX8o_f">服务A调用服务B的过程是应用间的内部过程，<b>牺牲可读性提升效率、易用性是可取的</b>。基于这种思路，RPC产生了。</p>
 <p data-pid="EzbCcTvi">通常，RPC要求在调用方中放置被调用的方法的接口。<b>调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用</b>。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-f6c29c414d2924b157ec555c6a664343_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="511" data-rawheight="287" data-original-token="v2-c5d945817ffb9751095f6f0ae9e2cba0" data-default-watermark-src="https://pic1.zhimg.com/50/v2-6012b46464aa21632f71a17e8b9d0528_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="511" data-original="https://pica.zhimg.com/v2-f6c29c414d2924b157ec555c6a664343_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="i6J9Wo3M">那要想实现这个过程该怎么办呢？别急，咱们一步一步来。</p>
 <p data-pid="klmWF5dS">首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。</p>
 <p data-pid="DH7LP6kF">第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：</p>
 <ul>
  <li data-pid="Z7WO-ezF">识别具体要调用的远程方法的IP、端口</li>
  <li data-pid="s3mFAmCL">将调用方法的入参进行序列化</li>
  <li data-pid="9p8xayTh">通过通信将请求发送到远程的方法中</li>
 </ul>
 <p data-pid="6gFuwPRL">这样，远程的服务就接收到了调用方的请求。它应该：</p>
 <ul>
  <li data-pid="JuQXbJ4Q">反序列化各个调用参数</li>
  <li data-pid="ZqqTI_0b">定位到实际要调用的方法，然后输入参数，执行方法</li>
  <li data-pid="f0TiCNPq">按照调用的路径返回调用的结果</li>
 </ul>
 <p data-pid="MV31e3cu">整个过程如下所示。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-bd07238f5104a05889a0f242ef8e33f0_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="571" data-rawheight="450" data-original-token="v2-e3cb1c3c4e2c274be9445be4ac0fee42" data-default-watermark-src="https://pica.zhimg.com/50/v2-dccb87f56936e66452d7ed42158d48d1_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="571" data-original="https://pic1.zhimg.com/v2-bd07238f5104a05889a0f242ef8e33f0_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="nR6mpYWO">这样，RPC操作就完成了。</p>
 <p data-pid="0CcNkIuh">调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的<b>通信数据可读性不需要好</b>，只需要RPC框架能读懂即可，因此<b>效率可以更高</b>。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。例如下面的示例中，为了保证实现最简单，就用了HTTP进行通信。</p>
 <p data-pid="fDuWNzy1">讲到这里，<b>RPC的产生原因、原理应该清楚了</b>。为了让大家真的明白，我写了一个真的是<b>最最简单的RPC实现</b>。把它放到了：</p><a href="https://link.zhihu.com/?target=https%3A//github.com/yeecode/EasyRPC" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/yeecode/Easy</span><span class="invisible">RPC</span><span class="ellipsis"></span></a>
 <p data-pid="xwk0WmsH">它包含一个客户端，一个服务端。客户端只要调用自身内部的接口，就通过这个小的RPC实现调用到了服务端的方法。</p>
 <p data-pid="A_TtHbe2">下面是客户端的代码，看着类有点多，其实代码不长。其中的RPC代码完成完成动态代理、远程调用参数序列化、远程调用发起、远程调用结果反序列化的工作。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-2bcd46610d7fbc08883047c5c77d6166_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="478" data-rawheight="347" data-original-token="v2-d8dfe7cdaeac5ee82bc3d348743e7b68" data-default-watermark-src="https://picx.zhimg.com/50/v2-74bb66b6aeb8050339a967cb4dd7692d_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="478" data-original="https://picx.zhimg.com/v2-2bcd46610d7fbc08883047c5c77d6166_r.jpg?source=1940ef5c">
  <figcaption>
   RPC客户端
  </figcaption>
 </figure>
 <p data-pid="X8G1tCo_">下面是服务端的代码，代码更少，完成远程调用接收、调用参数反序列化、调用实际触发、调用结果序列化的工作。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-1caa6254ad5961f216a2bc89004c2a7d_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="466" data-rawheight="242" data-original-token="v2-16d9548f295c41be4e1db5015424a769" data-default-watermark-src="https://picx.zhimg.com/50/v2-f479de6b1117cfc86629b57ebf26122b_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="466" data-original="https://picx.zhimg.com/v2-1caa6254ad5961f216a2bc89004c2a7d_r.jpg?source=1940ef5c">
  <figcaption>
   RPC服务端
  </figcaption>
 </figure>
 <p data-pid="Jdkch_pW">这样，一个RPC小框架就做完了，并不复杂。</p>
 <p data-pid="_T0GBXVn">所以，不要被RPC吓到，它就是<b>让一个应用调用另一个应用中方法的一种实现方式</b>。与调用远程接口区别不大，条条大路通罗马。</p>
 <p data-pid="BEydNBbB">再说一次，不是说RPC好，也不是说HTTP好，两者各有千秋。本质上，两者是<b>可读性和效率之间的抉择</b>，<b>通用性和易用性之间的抉择</b>。最终谁能发展更好，很难说。</p>
 <p data-pid="ooUmfYHb">要问我站谁？我<b>根据业务场景，灵活站位……</b></p>
 <p data-pid="UnmokDkS">如果还有什么没说清楚，可以留言讨论。</p>
 <hr>
 <p data-pid="peezwiug">【三年后更新】</p>
 <p data-pid="GGwQop7G">当初回答这个问题时，没想到引起这么多关注、获得这么多点赞。可见分布式的很多理论确实给大家带来了不小的困扰。</p>
 <p data-pid="FP_6RsfU">一致性（强一致性、最终一致性）、共识、PAXOS、Raft、Zookeeper等很多的概念、算法、框架，都给大家的学习带来了困扰。</p>
 <p data-pid="y_aL8-uJ">在之前的两本书籍都获得比较好的评价，并发行繁体版之后。我决定将分布式相关的理论、算法、实践知识整理和分享给出来，希望能帮助到大家。最近面世销售了。</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1470705528578334720"></a>
 <p data-pid="9EfnmxcM">【两个月后更新】</p>
 <p data-pid="Y1JjlUnH">在出版社获得了较高的评价，这本书也要发行繁体版了。</p>
 <p data-pid="pSann8EU">繁体版如下图所示。感觉名字比较霸气：平行运算，大有“平行宇宙”既视感！</p>
 <p data-pid="M-TwbJTZ">看来港台地区的互联网名词和我们差异真的挺大。</p>
 <figure data-size="small">
  <img src="https://picx.zhimg.com/50/v2-2cefa04ccd32aa3664ba8179fa6933fa_720w.jpg?source=1940ef5c" data-caption="" data-size="small" data-rawwidth="712" data-rawheight="916" data-original-token="v2-411434f51125d385ba0b1d9c13a5abbc" data-default-watermark-src="https://picx.zhimg.com/50/v2-4fc0eaf782cf9ab110c96d8b3de3d0bf_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="712" data-original="https://picx.zhimg.com/v2-2cefa04ccd32aa3664ba8179fa6933fa_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="891Qkngc">也可以<b>关注我</b>，偶尔出没解答架<b>构设计和编程</b>问题。</p>
</body>