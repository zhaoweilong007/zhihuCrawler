# 电脑软件（例如 Adobe、Autodesk）为什么那么容易被破解？
- 点赞数：21570
- 更新时间：2022年08月08日19时04分08秒
- 回答url：https://www.zhihu.com/question/356008082/answer/1128751775
<body>
 <p data-pid="dIL5DRk_">先说结论:</p>
 <p data-pid="oBUFKMBm">理论上不存在无法破解的软件,但并不是说破解软件比开发容易一万倍,naive,防破解的目的不是要做一个无法破解的软件,而是:</p>
 <h2><b>让破解软件的成本远大于购买软件的成本，知名软件大多都有实力让软件破解难度大大加大，但出于市场需求和争取用户的角度考虑，会放水！</b></h2>
 <p data-pid="TdDMC3mi">光说不练假把式,52老司机来给各位简略表演几个有代表性的软件破解,当然,要看懂下面的内容,需要一点点C语言的编程基础.</p>
 <p data-pid="xBhpVx_p">我们先来一个最最简单的软件破解,假设我们写了一个软件,它的注册手段代码如下</p>
 <div class="highlight">
  <pre><code class="language-c"><span class="cp">#include</span> <span class="cpf">"stdio.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"string.h"</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">Key</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"请输入注册码:"</span><span class="p">);</span>
	<span class="n">gets</span><span class="p">(</span><span class="n">Key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">Key</span><span class="p">,</span><span class="s">"abc123456"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"注册成功"</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"注册失败"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
 </div>
 <p data-pid="4sqCmT1K">把他编译成exe,运行一下</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-f827ea87e64d98eaf33806421d4515ba_720w.gif?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="509" data-original-token="v2-f827ea87e64d98eaf33806421d4515ba" data-thumbnail="https://pic1.zhimg.com/50/v2-f827ea87e64d98eaf33806421d4515ba_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="640" data-original="https://pic1.zhimg.com/v2-f827ea87e64d98eaf33806421d4515ba_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="TKS_6BMw">要破解怎么办呢?超简单的,你把这个程序后缀改成txt然后打开,搜索注册码.然后翻一翻key就找到了</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-b3ac7130c172d562c09921e26ad0e587_720w.gif?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="509" data-original-token="v2-b3ac7130c172d562c09921e26ad0e587" data-thumbnail="https://pic1.zhimg.com/50/v2-b3ac7130c172d562c09921e26ad0e587_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="640" data-original="https://pica.zhimg.com/v2-b3ac7130c172d562c09921e26ad0e587_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="VbxhQDQl">别笑,就算是今天,仍然有一大堆软件采用这种软件保护机制,不过这类软件要不大多不怎么值钱比如xx管理系统,计算器之类的,要不就是软件作者别有用心防君子不防小人.你可能会问了,问题出在那了呢,这类保护机制的问题是,目前大部分的编译器都会将字符串常量直接存储在可执行文件结构中,所以你要是硬编码key,那么上面这种破解方法几乎是屡试不爽甚至不需要什么逆向破解知识就能搞定.</p>
 <p data-pid="kX17A7oA">那么,让我们进入防破解V2.0时代,为了与时俱进,我们稍微把上面的代码改一下</p>
 <div class="highlight">
  <pre><code class="language-text">#include "stdio.h"
#include "string.h"
#include "windows.h"
#include "math.h"

int main()
{
	char iKey[32];
	char Key[32];
	char ID[32];
	int iID=0xabc1d3f;
	sprintf(Key,"%x",iID*8+123456);
	printf("你的机器码是%x\n",iID);
	printf("请输入注册码:");
	gets(iKey);
	if (strcmp(Key,iKey)==0)
		MessageBoxA(0,"注册成功","",MB_OK);
	else
		MessageBoxA(0,"注册失败","",MB_OK);
}</code></pre>
 </div>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-5134a887803327dc94470c5436647813_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="427" data-rawheight="361" data-original-token="v2-84d24efaa0bbd9dfb19e46aca9ee811d" data-default-watermark-src="https://picx.zhimg.com/50/v2-131b9e6a1ab35b5210908d0a4cbaf39e_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="427" data-original="https://picx.zhimg.com/v2-5134a887803327dc94470c5436647813_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="lUaT3cuo">现在"TXT"破解法已经不顶用了,你看,key找不到了</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-360071e44e37f312ef4f296d244bd611_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="616" data-rawheight="496" data-original-token="v2-0a5ca542ceb772c239b384f7f35c87f3" data-default-watermark-src="https://pic1.zhimg.com/50/v2-8fb1e96a20288ee73f0cd17378fd1359_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="616" data-original="https://picx.zhimg.com/v2-360071e44e37f312ef4f296d244bd611_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="uW2rec3t">怎么样,这种保护手段是不是熟悉的味道熟悉的配方,这个机器码可以从网卡MAC,CPU型号,内存大小等等等等去生成,当然,key的算法也可以拉上MD5,SHA等等等等手段来弄而不是简简单单的乘一个8再加上123456,总之从机器码到注册码的算法你能玩出花.</p>
 <p data-pid="jqC279lP">但,这又有什么卵用呢,打开ollydbg,对MessageBoxA下断点(也就是弹窗的函数)</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-f8b59fb9e91e67e9a7c9311639c866ed_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="944" data-rawheight="655" data-original-token="v2-3755b088a3084145573dc00ae17cc991" data-default-watermark-src="https://pic1.zhimg.com/50/v2-edae5ee8e04b46604e55ba1286f8ce8f_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="944" data-original="https://picx.zhimg.com/v2-f8b59fb9e91e67e9a7c9311639c866ed_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="0PEdp8uy">然后输入一个错误的注册码,命中断点,很快,我们来到了判断注册码是否正确的逻辑处理代码</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-3af7289cc2968bcbc96da2dcc3e17814_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="950" data-rawheight="560" data-original-token="v2-5f3dc8d4410e0d30403aa4e8f60afe6e" data-default-watermark-src="https://pic1.zhimg.com/50/v2-e95d633383881b7d2682c75cc9a84ab0_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="950" data-original="https://picx.zhimg.com/v2-3af7289cc2968bcbc96da2dcc3e17814_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="5qdKyi9g">你猜猜,要是我们把这个判断注册码是否正确的代码给它删了)(nop指令填充)会怎么样</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-7f29f38b6260d383e53f84ca01857224_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="945" data-rawheight="512" data-original-token="v2-13877f860d0becf023c5482e5cada5f8" data-default-watermark-src="https://picx.zhimg.com/50/v2-5da31e79a7277a73b0b57ac1642f0cd7_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="945" data-original="https://picx.zhimg.com/v2-7f29f38b6260d383e53f84ca01857224_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="BDjqnvi6">你会发现,握草,不管我输入什么,都是注册成功</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-7b8592df621d778ce2cae565e03ba2db_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="412" data-original-token="v2-a29748dd8cbd9a7468c75d342107a57b" data-default-watermark-src="https://picx.zhimg.com/50/v2-ece0bd5f1f70607b2cbe2b657f9c7fbb_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="585" data-original="https://pic1.zhimg.com/v2-7b8592df621d778ce2cae565e03ba2db_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="lrPDPpKO">那么问题出在哪了呢,你发现,万恶之源都始于那个MessageBox函数,正是这个函数,让我们顺藤摸瓜找到了注册码判断代码,时至今日,仍然有非常非常大的一部分软件使用着这个二三十年前就在用的保护手段,每年死于MessageBox被破解的软件,围起来可以绕地球三圈.也就是这个保护机制,成就了所谓软件发布后十分钟就被破解的悲惨结局.</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-f6f9f9306c5536cb2cf21cc941101ab4_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="498" data-rawheight="468" data-original-token="v2-9f941fc31791ba1d40016755d3b8b38c" data-default-watermark-src="https://picx.zhimg.com/50/v2-ee6e080b18fcc1c364a9b79371b8e1f8_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="498" data-original="https://picx.zhimg.com/v2-f6f9f9306c5536cb2cf21cc941101ab4_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="Ar7_XYfn">这个时候,你痛定思痛,mmp,有内鬼,既然MessageBox不好用,那我不用就是了,于是你把代码改成下面这样</p>
 <div class="highlight">
  <pre><code class="language-text">#include "stdio.h"
#include "string.h"
#include "windows.h"
#include "math.h"

int main()
{
	char iKey[32];
	char Key[32];
	char ID[32];
	int iID=0xabc1d3f;
	sprintf(Key,"%x",iID*8+123456);
	printf("你的机器码是%x\n",iID);
	printf("请输入注册码:");
	gets(iKey);
	if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
}</code></pre>
 </div>
 <p data-pid="B2tC-ZS6">你看,啧.只要你注册码没输对,我直接把软件退出(或者跳到别的地方),看你怎么办</p>
 <p data-pid="819MAivF">可惜,内鬼年年有,"注册成功"几个字还是出卖了你,打开ollydbg,查找字符串参考,然后双击</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-497704e59471ba56185cf9e76fa11939_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="955" data-rawheight="691" data-original-token="v2-f38d184fb946bcf2429fdc71fc08a15c" data-default-watermark-src="https://pica.zhimg.com/50/v2-63b042b3924b95ef0417f8fbb7a8d57d_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="955" data-original="https://pic1.zhimg.com/v2-497704e59471ba56185cf9e76fa11939_r.jpg?source=1940ef5c">
 </figure>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-20435dbd15717a722a64484e79da9ac3_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="945" data-rawheight="557" data-original-token="v2-6098c8498484c184bd48f608d7add259" data-default-watermark-src="https://pic1.zhimg.com/50/v2-7a3b7cb90c188ba010d8a49a135979de_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="945" data-original="https://pic1.zhimg.com/v2-20435dbd15717a722a64484e79da9ac3_r.jpg?source=1940ef5c">
 </figure>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-2eb5e998be0ead0667cf7a3978088f88_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="231" data-rawheight="203" data-original-token="v2-f6b8322898a36707e312581076ff49ea" data-default-watermark-src="https://pica.zhimg.com/50/v2-c564f86cccc988a901d59c62eb54be26_720w.jpg?source=1940ef5c" class="content_image" width="231">
 </figure>
 <p data-pid="oPzs9_mB">哦豁,完蛋,换汤不换药,还是给逮住了.</p>
 <p data-pid="RyYSiiuQ">你察觉到这样一个地方判断注册码实在不靠谱,所以,你改变了策略,把检查注册码的代码复制了n遍,或者逐字符检查注册码的准确性，还有人将注册成功等字样进行加密或混淆，等到要用的时候再取出来</p>
 <div class="highlight">
  <pre><code class="language-text">#include "stdio.h"
#include "string.h"
#include "windows.h"
#include "math.h"

int main()
{
	char iKey[32];
	char Key[32];
	char ID[32];
	int iID=0xabc1d3f;
	sprintf(Key,"%x",iID*8+123456);
	printf("你的机器码是%x\n",iID);
	printf("请输入注册码:");
	gets(iKey);
	if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
}</code></pre>
 </div>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-7cad2297118f24bdff915da9718f7caa_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="303" data-rawheight="266" data-original-token="v2-5e7edb0c76b0afbb758585bf9198d1c7" data-default-watermark-src="https://picx.zhimg.com/50/v2-e3c5c2dadb079beb795c659550b6f97b_720w.jpg?source=1940ef5c" class="content_image" width="303">
 </figure>
 <p data-pid="OkpZsLyM">你放心,不管你复制多少次,要找出来都是时间问题,吃枣是会被破解的.同时只要你要用到明文字符串你迟早还是要解密的，这种手段类似于加upx压缩壳，只需要等待数据解压完成，所有的东西又都是明文的了。因此比较聪明的做法是，要用时解密，用完后马上把明文抹掉，这样说不定能拖延更长的时间。但这仍然也是时间问题。</p>
 <p data-pid="J4RatOyp">你开始发现,与其揪出内鬼,不如主动出击,也就是我们著名的与其解决问题不如解决提出问题的人,终于,你开始对调试器下手了,然后你成功进化到防破解V2.5时代.</p>
 <p data-pid="x3-gdrw2">这个时候,不得不介绍一个老掉牙的但非常有名的函数</p>
 <p data-pid="J2Ki32eT">IsDebugPresent</p>
 <p data-pid="7wKuB0Qt">你可能有点懵,这个函数是干啥子用的?,简单来说,当我们破解一个程序的时候,大部分情况下我们会打开一个叫调试器的东西来对软件进行反编译分析,诶,重点就在这,IsDebugPresent这个函数,就能检测我们的程序有没有被一个调试器附加,你想啊,正常情况我们用软件谁会吃饱撑着附加一个调试器来用,你要是用调试器附加我,你肯定就是想干坏事.</p>
 <p data-pid="Z4IghPOk">于是,你开始把代码写成这样:</p>
 <div class="highlight">
  <pre><code class="language-text">#include "stdio.h"
#include "string.h"
#include "windows.h"
#include "math.h"

int main()
{
	char iKey[32];
	char Key[32];
	char ID[32];
	int iID=0xabc1d3f;
	if (IsDebuggerPresent())
	{
		MessageBoxA(NULL,"小样,就你还破解我的程序,回家喝奶去吧","",MB_OK);
		return 0;
	}
	sprintf(Key,"%x",iID*8+123456);
	printf("你的机器码是%x\n",iID);
	printf("请输入注册码:");
	gets(iKey);
	if (strcmp(Key,iKey)==0)
		printf("注册成功");
	else
		exit(0);
}</code></pre>
 </div>
 <p data-pid="qkcArZz4">于是,当下次再ollydbg加载调试你的程序的时候,就会出现下面的情景</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-ef408fc44e144d866e4adbf23566bae0_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="785" data-rawheight="507" data-original-token="v2-1f0363d99cd43ff17826cd10a73262e2" data-default-watermark-src="https://picx.zhimg.com/50/v2-12dc2432b83baf6541f40f7cdbbc890a_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="785" data-original="https://pic1.zhimg.com/v2-ef408fc44e144d866e4adbf23566bae0_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="tXTaOkI1">曾经很长一段时间(包括现在),很多软件或加密壳都会检查是否有调试器正在调试自己,比如tls段会在加载时被执行,如果检查到自己正在被人调试破解,就会设置一个tag让程序跑到没啥用的地方去或者直接退出重新,也有利用变形的PE头让调试器无法加载,总之手段很多.</p>
 <p data-pid="_Z-SsmVn">可惜这还是没什么卵用,比如IsDebugPresent可以通过修改FS寄存器的标志位来让它彻底哑火,同样的手段包括但不限于检查int 3软中断,Raw Call,Query PEB,检查Debug Privilege和父进程等等等等,都有绕过的方式.</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-f4c24ab9c3a1c7cafc00a0d727dc842f_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="586" data-rawheight="630" data-original-token="v2-a95ec810c017786befb309d9c9127164" data-default-watermark-src="https://picx.zhimg.com/50/v2-e3a6fa3ec0f7efed2b28b317cf52e687_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="586" data-original="https://picx.zhimg.com/v2-f4c24ab9c3a1c7cafc00a0d727dc842f_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="6lVhNJey">暗桩嘛,只要你插,一个一个拔总是拔的完的</p>
 <p data-pid="hNvp8qc4">好了,还有啥法子不,放心道高一尺魔高一丈,现在我们来到了现在最流行的,防破解V3.0 VMP时代,</p>
 <p data-pid="RYjDhAQg">先澄清一下,这里的VMP并不是VMP壳,它全程叫Virtual Machine Protection,简单来说,为啥我们破解软件那么轻车熟路,还不是因为x86 x64 arm的那堆汇编指令集我们太熟悉了呗.要是我们自己发明一套指令集,然后用这个指令集写程序并运行在我们自己的虚拟机上,那么,破解者一进来,看到的不就是一脸懵逼了么</p>
 <p data-pid="4-ghyUnq">可惜的是,VM的运行机制决定了它可能造成几十倍乃至几百倍的性能损失,所以,VMP必须用于保护那种关键且不是性能瓶颈的代码,否者你的软件跑起来就会像</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-37681f6c5f8b4388a22c7a1dfddc9a0c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="491" data-rawheight="284" data-original-token="v2-d61f759c66d5642fb11bf54a00ac668d" data-default-watermark-src="https://picx.zhimg.com/50/v2-b1df80559af180c76458c4af35bb89f9_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="491" data-original="https://picx.zhimg.com/v2-37681f6c5f8b4388a22c7a1dfddc9a0c_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="1OVQzrab">如果你想了解VM机运行机制,诶,笔者刚好也做了个</p><a href="https://zhuanlan.zhihu.com/p/72356928" data-draft-node="block" data-draft-type="link-card" class="internal">DBinary：从虚拟机架构到编译器实现</a>
 <p data-pid="GnUZGtx2">那么,VMP保护机制是完美的么,当然不是,VMP说白了,也只能做到延长分析时间,你要是把VMP做的足够复杂,足够让一个Cracker醉生梦死了,但是如果这个时间足够久,你的软件足够的值钱让人有欲望来破解, 他们仍然可以充分地分析你VM机的运行机制,当你的VM机运行机制被摸清了,软件就离沦陷不远了.</p>
 <p data-pid="CBBasyBG">不过你可以放心,分析VM机执行机理,可比自己写VM机要头疼多了,毕竟一个是你需要通过代码来揣测别人的思路,而另一个本身是自己的思路转为代码,因此基于这点可以说:</p>
 <p data-pid="GyZm_4pL">破解软件比制作软件简单,在很多情况下,不存在的!</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-9904756f5bcf26ceefbad8ec5765b3ca_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="178" data-rawheight="198" data-original-token="v2-9904756f5bcf26ceefbad8ec5765b3ca" class="content_image" width="178">
 </figure>
 <p data-pid="AchX7CES">你可能会问了,为什么现在市面上那么多软件,那么多游戏,购买了那么多听起来那么牛逼的保护软件,结果还是被破解了.而且刚发出来一天就被破解了.</p>
 <p data-pid="3BBhWwnS">其实很大的问题就出在这个商业保护软件(比如保护壳)上,因为这类保护壳大多都会被卖给一大票的软件开发商,有一句话叫树大招风,就像现在流行的VMP保护机制,之所以能保护,是因为其运行机理破解者不明确,如果你这个软件就给自己用,而且你这软件还不怎么值钱,除非大佬空虚寂寞冷,不然谁会有那闲工夫去分析你的虚拟机是怎么跑的,但商业保护壳不同,不论其采用什么样的保护机制,只要分析过一遍搞清楚了,几乎所有使用这类保护机制的软件都会沦陷,而且在灰色产业上.这种破解甚至还颇有利可图,只要这个保护机制不更新,一次投入,长期回报.于是只有说在第一次分析时会花上很长的时间,之后就都只是玩套路了.</p>
 <p data-pid="4vQaPPQv">因此,购买商业保护壳,其实其保护效果并没有想象中的那么强,很可能在灰色产业中形同虚设,甚至一个具有反逆向基础的码农自己写的说不定还更有效果.当然一个软件是被破解概率高不高,仍然是我之前提到的那句话:防破解不是让软件无法破解,而是让破解软件的成本远大于购买软件的成本</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-375c3b65cf7562719e50bbbd8173dc88_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="407" data-rawheight="347" data-original-token="v2-1176beaeb4a9b39700d1c096fce0b52b" data-default-watermark-src="https://picx.zhimg.com/50/v2-4a623e8f6bd706cc6ed5e822fc13f437_720w.jpg?source=1940ef5c" class="content_image" width="407">
 </figure>
 <p data-pid="DCoLz-93">毕竟你说你一个软件拿来开源都没人爱用,你还整天琢磨着怎么才不会被破解,寒掺不老铁.</p>
 <p data-pid="pIKDsFKG">那么你会开始问了,有没有更给力点的防破解技术?好像之前说的说来说去,无非就是拖延时间,诶,这个我们要摆正心态,不论是加密还是破解,其实说白了最终就是拖延时间,你看那些加密算法,依据其数学理论,如果要破解,它的计算量就算你把全世界的计算机加起来一块算,也够你算三个世界末日了.</p>
 <p data-pid="_oomYpGY">不过别担心,更给力的方法还是有的,你想啊,为什么我们之前说了那么多软件都被破解了,最最关键的一个原因,是我们能搞到代码,即使这个代码已经是经过编译后的一堆汇编指令,但只要我们有这堆代码,迟早我们还是能搞懂这个程序是怎么回事的,然后我们就可以对症下药干坏事.</p>
 <p data-pid="ti4u9PO7">这就像给你有一包面粉,而程序就是一个面包机,你把面粉塞进面包机做出了面包,有天你好奇啊,这面包机咋整咋整就出来一块面包了呢,你就动手把面包机拆了,然后你就知道面包机是怎么回事了.</p>
 <p data-pid="yFoS9Mv5">所以有没有办法不让用户知道我们的代码是什么样的呢,就像你把面粉交给了面包师傅做面包,这个面包是怎么做的,你就只能指望看面包师傅有没有这个心情告诉你了.</p>
 <p data-pid="pux8FBe2">为此,有请早期一个相当流行且普遍的游戏防破解工具(物理)</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-6d3b81f990b1c9f83925bdd3d5e12412_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="447" data-original-token="v2-35b53feb67644ebbba0708c01462caf1" data-default-watermark-src="https://picx.zhimg.com/50/v2-ae2b74726dedb8f44db3c760a44d32e9_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="444" data-original="https://picx.zhimg.com/v2-6d3b81f990b1c9f83925bdd3d5e12412_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="HbiQk0cM">你现在可能表情是一脸问号,但我没和你开玩笑,在2000年时代,大部分的游戏运行在光盘CD中,但盗版也容易啊,把光盘里的数据一复制下来,然后就可以复制出一万张盗版光碟,所以游戏厂商们就想办法,想来想去就想到了榔头</p>
 <p data-pid="OVxHpmu3">其操作方法很简单,拿榔头和钉子,在光盘上钉几条刮痕出来,造成人工的坏道,然后再将数据烧录到正确的扇区中,这样下来虽然程序还是可以正确运行,但是当光头读盘读到这个坏道的时候,就会读不过去,于是你会发现打开光盘后,没有关键的文件,这样你就没办法将游戏或者说程序拷贝出来了,同时还会对坏道的位置做一个标记,游戏运行时也会检查这个标记,那么想要盗版你就也得拿起榔头在光盘同样的位置上砸出同样的刮痕出来,当然,这几乎是不可能的.</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-1e473e9c7cca9cef69bbf64e9969b72e_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="331" data-rawheight="402" data-original-token="v2-e6cf83f20b6460ef9716a1eb3fdc9c5f" data-default-watermark-src="https://picx.zhimg.com/50/v2-5db303df45860ef14236bd14386adfea_720w.jpg?source=1940ef5c" class="content_image" width="331">
 </figure>
 <p data-pid="qlB6VpFX">当年这个技术当年又叫防盗环技术,但不管它的名字叫的多高大上,本质上就和榔头钉钉子如出一辙是同样的东西,可惜虚拟光驱出现后,同样有办法复刻光盘的一切数据(包括坏道),所以,这个技术拿到今天来看并没有什么卵用.不过这仍然给了我们足够的启发.</p>
 <p data-pid="iG7DfXx1">现在让我们进入防破解V3.x时代,之所以不叫V4.0是因为这类技术很早就有并且比VMP保护流行的时间还早的多,而且它可能是最近接理论上不可破解的防破解手段.</p>
 <p data-pid="-jAx11Fc">我们先聊的是加密狗或者又叫Ukey保护,就是运行软件你需要插入一个U盘一样的东西到电脑上,实际上这个Ukey是一个微型电脑,软件的一些关键的算法和代码,都在这个UKey的芯片里,当我们PC上的软件运行后,当我们需要执行这类关键算法时,我们会向这个Ukey传递数据,然后UKey将结果计算出来,返回给PC的软件上,这样就避免了用户直接能够逆向取得关键的算法代码,破解也就无从谈起了.这也就是为什么到了今天,Ukey保护仍然非常的流行.</p>
 <p data-pid="zYZLdZbh">可惜,UKey保护仍然有诸多的限制,首先就是带着一个Ukey贼麻烦,万一UKey丢了补办是一个麻烦事,运行软件插Ukey也是个神烦的事情,同时,UKey的性能决定了它可能不能执行一些过于消耗性能和内存空间的代码,数据交互也因带宽和通讯延迟会造成性能损失,所以它和VMP保护机制一样,同样不是一个省油的灯,同时开发人员的水平不到位,该保护的代码没保护,保护来没啥用的代码塞了一堆,也会给Cracker带来机会,而且只要你的软件够值钱,你是不是太瞧不起我华强北了</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-416d1d5f367948147787ce59c24a18e5_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="395" data-rawheight="228" data-original-token="v2-ac7c7249994bc29c479fe1667fe60244" data-default-watermark-src="https://picx.zhimg.com/50/v2-bb3305c41a489d6fc5797d25015bd917_720w.jpg?source=1940ef5c" class="content_image" width="395">
 </figure>
 <p data-pid="0kjmFkcd">把Ukey拆开来,使用某种"药水"剥开外层找到内部的芯片并接上已经熔断的"读引脚"(有些芯片连这步都省了,直接热风枪一吹接板读ROM) 然后再把芯片的代码给读出来</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-52c537f8fea18f15d7e0200591b92db1_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="285" data-rawheight="186" data-original-token="v2-8077e121c984608df593e4d907d1fca2" data-default-watermark-src="https://pic1.zhimg.com/50/v2-70f27784b41e7921774505a61bea4634_720w.jpg?source=1940ef5c" class="content_image" width="285">
 </figure>
 <p data-pid="sLw9mrtN">于是,UKey保护也宣布沦陷.</p>
 <p data-pid="FJ10lNes">你发现,只要是把实体的东西交到用户的手上,迟早会出问题,所以,这个Ukey保护现在大部分情况下变成了带数字证书的网络验证模式,这类的关键代码从Ukey转移到了服务器上,数据交互通过网络来做.其实这种保护机制和Ukey保护原理是一样的并没有什么本质的区别,但同样处于网络带宽也延迟的考虑,同样具有一定的性能损失和设计缺陷.</p>
 <h2>需要重点提及的是,这类网络保护的手段必须专门设计以保护程序中的一系列关键"功能"代码而不是"防破解"代码(比如代码解密,注册验证),因为后者几乎没啥卵用仍然能够将"防破解"的代码清除或Dump解密代码或伪造本地服务器实现破解.</h2>
 <p data-pid="oGkGNJyB">所以你指望一堆什么x盾,x宝一键能一劳永逸一键保护程序,程序必须经过专业码农而不是彩笔专门的设计才能起到其应有的保护效果</p>
 <p data-pid="ogZmD3eo">但现实情况是,处于用户离线运行和性能延迟瓶颈的考虑,这种网络保护设计的往往都有很大的缺陷,因此,并不是说这东西不好,而是理想很丰满现实很骨干,实在无能为力啊.</p>
 <p data-pid="4RxF9RYi">当然,代码保护的手段很多且花样玩法也很多,本文只是初略介绍几个比较有代表性的破解和反破解手段.如有兴趣</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-049bb8003bbcb01a038bde4562b31f4c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="369" data-original-token="v2-bbffaaa4a62ce27da42f33ee385cf82e" data-default-watermark-src="https://picx.zhimg.com/50/v2-f3d56c0b8b9ff5bb5c02d40b353282e8_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic1.zhimg.com/v2-049bb8003bbcb01a038bde4562b31f4c_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="EJlod4hZ">附上自己的引擎,欢迎点star</p><a href="https://link.zhihu.com/?target=https%3A//www.painterengine.com/index.html" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">PainterEngine 一个由C语言编写的完整开源的跨平台图形应用框架</a>
 <p></p>
</body>