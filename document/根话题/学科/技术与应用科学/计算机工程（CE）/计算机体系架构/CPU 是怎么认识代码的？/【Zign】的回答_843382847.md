# CPU 是怎么认识代码的？
- 点赞数：20282
- 更新时间：2019年10月16日14时11分25秒
- 回答url：https://www.zhihu.com/question/348237008/answer/843382847
<body>
 <p data-pid="ee6-qOR8">又是读个大学就能懂系列的。</p>
 <p data-pid="8KhnZWOr">行吧，老规矩，尽量简单的语言来解释一下。</p>
 <p data-pid="qoImxy2T">先说一下半导体，啥叫半导体？就是介于导体和绝缘体中间的一种东西，比如二极管。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-15444640740ee87a5ae8d64c8990a80b_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="375" data-rawheight="178" data-original-token="v2-f28a95153c81d97fef4f2dfea6e041cb" data-default-watermark-src="https://picx.zhimg.com/50/v2-628314744d18bda74250fdfed5138f95_720w.jpg?source=1940ef5c" class="content_image" width="375">
 </figure>
 <p data-pid="azg_ddC-">电流可以从A端流向C端，但反过来则不行。你可以把它理解成一种防止电流逆流的东西。</p>
 <p data-pid="1F0DuP1t">当C端10V，A端0V，二极管可以视为断开。</p>
 <p data-pid="_PDCExZv">当C端0V，A端10V，二极管可以视为导线，结果就是A端的电流源源不断的流向C端，导致最后的结果就是A端=C端=10V</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-ca6df836eb7a6e6233a0802d744b9690_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="2048" data-rawheight="1150" data-original-token="v2-f5f5d02e076968e70c0fb18270a5d2a2" data-default-watermark-src="https://picx.zhimg.com/50/v2-c7b1e4877c7041b0ab29259e4c013f67_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="2048" data-original="https://picx.zhimg.com/v2-ca6df836eb7a6e6233a0802d744b9690_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="-FW0PlgQ">等等，不是说好的C端0V，A端10V么？咋就变成结果是A端=C端=10V了？你可以把这个理解成初始状态，当最后稳定下来之后就会变成A端=C端=10V。</p>
 <p data-pid="leqtFqg2">文科的童鞋们对不住了，实在不懂问高中物理老师吧。反正你不能理解的话就记住这种情况下它相当于导线就行了。</p>
 <hr>
 <p data-pid="_A3TN3Rg">利用半导体的这个特性，我们可以制作一些有趣的电路，比如【与门】</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-f0c941bb94dbaff62ffdb235252c4566_720w.gif?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="372" data-rawheight="213" data-original-token="v2-f0c941bb94dbaff62ffdb235252c4566" data-thumbnail="https://pica.zhimg.com/50/v2-f0c941bb94dbaff62ffdb235252c4566_720w.jpg?source=1940ef5c" class="content_image" width="372">
 </figure>
 <p data-pid="vsyApCEo">此时A端B端只要有一个是0V，那Y端就会和0V地方直接导通，导致Y端也变成0V。只有AB两端都是10V，Y和AB之间才没有电流流动，Y端也才是10V。</p>
 <p data-pid="NoM6_6BR">我们把这个装置成为【与门】，把有电压的地方计为1，0电压的地方计为0。至于具体几V电压，那不重要。</p>
 <p data-pid="zVKgdEKQ">也就是AB必须同时输入1，输出端Y才是1;AB有一个是0，输出端Y就是0。</p>
 <p data-pid="TZGZW_7D">其他还有【或门】【非门】和【异或门】，跟这个都差不多，或门就是输入有一个是1输出就是1，输入00则输入0。</p>
 <p data-pid="f2AgZ-Tx">非门也好理解，就是输入1输出0，输入0输出1。</p>
 <p data-pid="ZWC_QaIF">异或门难理解一些，不过也就那么回事，输入01或者10则输出1，输入00或者11则输出0。（即输入两个一样的值则输出0，输入两个不一样的值则输出1）。</p>
 <p data-pid="Hzw7aYpd">这几种门都可以用二极管或者三极管做出来，具体怎么做就不演示了，有兴趣的童鞋可以自己试试。当然实际并不是用二极管三极管做的，因为它们太费电了。实际是用场效应管（也叫MOS管）做的。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-75b990b9e561ed28949ad888a6e8d427_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1595" data-rawheight="1295" data-original-token="v2-556e166612900558f5007d5d8599ef2c" data-default-watermark-src="https://pica.zhimg.com/50/v2-a252d578567631f0699afb38460be9e1_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1595" data-original="https://pic1.zhimg.com/v2-75b990b9e561ed28949ad888a6e8d427_r.jpg?source=1940ef5c">
 </figure>
 <hr>
 <p data-pid="Ffv50aoJ">然后我们就可以用门电路来做CPU了。当然做CPU还是挺难的，我们先从简单的开始：加法器。</p>
 <p data-pid="S0PoGkix">加法器顾名思义，就是一种用来算加法的电路，最简单的就是下面这种。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-89eaaa11986cbe311355c21774d5527d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="183" data-original-token="0e5d6a50e91c56118c82bb896f63b303" data-default-watermark-src="https://picx.zhimg.com/50/v2-9a538d895f705315e0aa5a56a9566b97_720w.jpg?source=1940ef5c" class="content_image" width="330">
 </figure>
 <p data-pid="CE2QVypm">AB只能输入0或者1，也就是这个加法器能算0+0，1+0或者1+1。</p>
 <p data-pid="0WwEgmPu">输出端S是结果，而C则代表是不是发生进位了，二进制1+1=10嘛。这个时候C=1，S=0</p>
 <p data-pid="9lpSieO1">费了大半天的力气，算个1+1是不是特别有成就感？</p>
 <p data-pid="pu9jrKuA">那再进一步算个1+2吧（二进制01+10），然后我们就发现了一个新的问题：第二位需要处理第一位有可能进位的问题，所以我们还得设计一个全加法器。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-e59039de261d99b15200e546fdc8974a_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="149" data-original-token="v2-5dd07a9a2d56a600c030138ccba275bd" data-default-watermark-src="https://picx.zhimg.com/50/v2-150d2d080523692432c7cd9a6acb731a_720w.jpg?source=1940ef5c" class="content_image" width="330">
 </figure>
 <p data-pid="E_TsNzpO">每次都这么画实在太麻烦了，我们简化一下</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-53dc37da3b8fb637750d6e5f10213a0f_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="284" data-original-token="v2-2e1600f558de4e74336e97bdfb6b5798" data-default-watermark-src="https://picx.zhimg.com/50/v2-0a531243e74e87d159dfef597a32aada_720w.jpg?source=1940ef5c" class="content_image" width="330">
 </figure>
 <p data-pid="PCjWxKa6">也就是有3个输入2个输出，分别输入要相加的两个数和上一位的进位，然后输入结果和是否进位。</p>
 <p data-pid="Ue88BjSF">然后我们把这个全加法器串起来</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-8703016fa5f3ca95c0b009ece1b6bb76_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="132" data-original-token="v2-8bc1f3eb35b0247f64a5d7de20827958" data-default-watermark-src="https://pica.zhimg.com/50/v2-374d0c6d8b2ef9ad0d36695716e6d260_720w.jpg?source=1940ef5c" class="content_image" width="330">
 </figure>
 <p data-pid="4YLedTWL">我们就有了一个4位加法器，可以计算4位数的加法也就是15+15，已经达到了幼儿园中班水平，是不是特别给力？</p>
 <hr>
 <p data-pid="UJWZHNzr">做完加法器我们再做个乘法器吧，当然乘任意10进制数是有点麻烦的，我们先做个乘2的吧。</p>
 <p data-pid="brJmyIrs">乘2就很简单了，对于一个2进制数数我们在后面加个0就算是乘2了</p>
 <div class="highlight">
  <pre><code class="language-text">比如
5=101（2）
10=1010（2）</code></pre>
 </div>
 <p data-pid="LHlsYrnU">所以我们只要把输入都往前移动一位，再在最低位上补个零就算是乘2了。具体逻辑电路图我就不画，你们知道咋回事就行了。</p>
 <p data-pid="QOHKQutB">那乘3呢？简单，先位移一次（乘2）再加一次。乘5呢？先位移两次（乘4）再加一次。</p>
 <p data-pid="enHS6edi">所以一般简单的CPU是没有乘法的，而乘法则是通过位移和加算的组合来通过软件来实现的。这说的有点远了，我们还是继续做CPU吧。</p>
 <p data-pid="CKQ9hGg8">现在假设你有8位加法器了，也有一个位移1位的模块了。串起来你就能算</p>
 <div class="highlight">
  <pre><code class="language-text">（A+B）X2</code></pre>
 </div>
 <p data-pid="8hyC2G8e">了！激动人心，已经差不多到了准小学生水平。</p>
 <p data-pid="DAtAkcJ6">那我要是想算</p>
 <div class="highlight">
  <pre><code class="language-text">AX2+B</code></pre>
 </div>
 <p data-pid="DrohQcgm">呢？简单，你把加法器模块和位移模块的接线改一下就行了，改成输入A先过位移模块，再进加法器就可以了。</p>
 <p data-pid="DYiMOVpo">啥？？？？你说啥？？？你的意思是我改个程序还得重新接线？</p>
 <p data-pid="rf-kN_Ll">所以你以为呢？编程就是把线来回插啊。</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-f7399a51d1fe39799ffd4060fe756f5d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="937" data-rawheight="552" data-original-token="v2-2141f212ffeb4179c3b282c4233632a5" data-default-watermark-src="https://picx.zhimg.com/50/v2-08745fdba36931bc43fcff3cae988c54_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="937" data-original="https://pica.zhimg.com/v2-f7399a51d1fe39799ffd4060fe756f5d_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="3nH06GN0">惊喜不惊喜？意外不意外？</p>
 <p data-pid="UEgBoSWI">早期的计算机就是这样编程的，几分钟就算完了但插线好几天。而且插线是个细致且需要耐心的工作，所以那个时候的程序员都是清一色的漂亮女孩子，穿制服的那种，就像照片上这样。是不是有种生不逢时的感觉？</p>
 <hr>
 <p data-pid="ZemSx8ZE">虽然和美女作伴是个快乐的事，但插线也是个累死人的工作。所以我们需要改进一下，让CPU可以根据指令来相加或者乘2。</p>
 <p data-pid="wo460xNs">这里再引入两个模块，一个叫flip-flop，简称FF，中文好像叫触发器。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-e538765c41d278774809c98af7b4795b_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="315" data-rawheight="214" data-original-token="v2-f2f3a7bd6fcc65804e171eca06356f14" data-default-watermark-src="https://pica.zhimg.com/50/v2-e40d8f2415cd6cdbca3c130c177ec13f_720w.jpg?source=1940ef5c" class="content_image" width="315">
 </figure>
 <p data-pid="e_smwZro">这个模块的作用是存储1bit数据。比如上面这个RS型的FF，R是Reset，输入1则清零。S是Set，输入1则保存1。RS都输入0的时候，会一直输出刚才保存的内容。</p>
 <p data-pid="qVZP3pUi">我们用FF来保存计算的中间数据（也可以是中间状态或者别的什么），1bit肯定是不够的，不过我们可以并联嘛，用4个或者8个来保存4位或者8位数据。这种我们称之为寄存器（Register）。</p>
 <p data-pid="sOYPOvXt">另外一个叫MUX，中文叫选择器。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-aa4dac2c7677c6cc0679dde3bba32293_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="179" data-original-token="v2-46af920ecb4ab3f514f4cb3b235977fc" data-default-watermark-src="https://pic1.zhimg.com/50/v2-9309fce6cd9a2e6fa48059c1c07b6fb9_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="450" data-original="https://picx.zhimg.com/v2-aa4dac2c7677c6cc0679dde3bba32293_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="OujcdE-Q">这个就简单了，sel输入0则输出i0的数据，i0是什么就输出什么，01皆可。同理sel如果输入1则输出i1的数据。当然选择器可以做的很长，比如这种四进一出的</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-97b1cfb31cd892e58c2fb9ad72a392dc_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="300" data-rawheight="460" data-original-token="v2-f6100bb218fe6e3091d2868f3ff641bc" data-default-watermark-src="https://picx.zhimg.com/50/v2-de9ae67514216ba8157c6feaa610132e_720w.jpg?source=1940ef5c" class="content_image" width="300">
 </figure>
 <p data-pid="GU4CFzr5">具体原理不细说了，其实看看逻辑图琢磨一下就懂了，知道有这个东西就行了。</p>
 <p data-pid="3ei-i34h">有这个东西我们就可以给加法器和乘2模块（位移）设计一个激活针脚。</p>
 <p data-pid="pNzgGQT7">这个激活针脚输入1则激活这个模块，输入0则不激活。这样我们就可以控制数据是流入加法器还是位移模块了。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <hr>
 <p data-pid="rmVKNTWF">于是我们给CPU先设计8个输入针脚，4位指令，4位数据。</p>
 <p data-pid="46a9Xr3t">我们再设计3个指令：</p>
 <p data-pid="lXA2_u-D">0100，数据读入寄存器</p>
 <p data-pid="R3PrkX5h">0001，数据与寄存器相加，结果保存到寄存器</p>
 <p data-pid="2SoqygW1">0010，寄存器数据向左位移一位（乘2）</p>
 <p data-pid="jPjPOa9R">为什么这么设计呢，刚才也说了，我们可以为每个模块设计一个激活针脚。然后我们可以分别用指令输入的第二第三第四个针脚连接寄存器，加法器和位移器的激活针脚。</p>
 <p data-pid="TL-PGHqB">这样我们输入0100这个指令的时候，寄存器输入被激活，其他模块都是0没有激活，数据就存入寄存器了。同理，如果我们输入0001这个指令，则加法器开始工作，我们就可以执行相加这个操作了。</p>
 <p data-pid="TBCElgop">这里就可以简单回答这个问题的第一个小问题了：</p>
 <p data-pid="gqsxrZ6r"><b>那cpu 是为什么能看懂这些二级制的数呢？</b></p>
 <p data-pid="7W3gOidS">为什么CPU能看懂，因为CPU里面的线就是这么接的呗。你输入一个二进制数，就像开关一样激活CPU里面若干个指定的模块以及改变这些模块的连同方式，最终得出结果。</p>
 <p data-pid="9Ds9ywW1">几个可能会被问道的问题</p>
 <p data-pid="MICnk5oF">Q：CPU里面可能有成千上万个小模块，一个32位/64位的指令能控制那么多吗？</p>
 <p data-pid="3fzZslY8">A：我们举例子的CPU里面只有3个模块，就直接接了。真正的CPU里会有一个解码器（decoder），把指令翻译成需要的形式。</p>
 <p data-pid="ohYU2Rrq">Q：你举例子的简单CPU，如果我输入指令0011会怎么样？</p>
 <p data-pid="aIQ6LYh-">A：当然是同时激活了加法器和位移器从而产生不可预料的后果，简单的说因为你使用了没有设计的指令，所以后果自负呗。（在真正的CPU上这么干大概率就是崩溃呗，当然肯定会有各种保护性的设计，死也就死当前进程）</p>
 <hr>
 <p data-pid="TGFHYIRq">细心的小伙伴可能发现一个问题：你设计的指令</p>
 <p data-pid="syaKGSdb">【0001，数据与寄存器相加，结果保存到寄存器】</p>
 <p data-pid="ZDOMTYLn">这个一步做不出来吧？毕竟还有一个回写的过程，实际上确实是这样。我们设计的简易CPU执行一个指令差不多得三步，读取指令，执行指令，写寄存器。</p>
 <p data-pid="Vkra4gu7">经典的RISC设计则是分5步：读取指令(IF)，解码指令(ID)，执行指令(EX)，内存操作(MEM)，写寄存器(WB)。我们平常用的x86的CPU有的指令可能要分将近20个步骤。</p>
 <p data-pid="fHLvAd_t">你可以理解有这么一个开关，我们啪的按一下，CPU就走一步，你按的越快CPU就走的越快。咦？听说你有个想法？少年，你这个想法很危险啊，姑且不说你有没有麒麟臂，能不能按那么快（现代的CPU也就2GHz多，大概也就一秒按个20亿下左右吧）</p>
 <p data-pid="xdNdV_yH">就算你能按那么快，虽然速度是上去了，但功耗会大大增加，发热上升稳定性下降。江湖上确实有这种玩法，名曰超频，不过新手不推荐你尝试哈。</p>
 <p data-pid="dm_CI-7O">那CPU怎么知道自己走到哪一步了呢？前面不是介绍了FF么，这个不光可以用来存中间数据，也可以用来存中间状态，也就是走到哪了。</p>
 <p data-pid="6DHwkX-p">具体的设计涉及到FSM（finite-state machine），也就是有限状态机理论，以及怎么用FF实装。这个也是很重要的一块，考试必考哈，只不过跟题目关系不大，这里就不展开讲了。</p>
 <hr>
 <p data-pid="TQJCC5IC">我们再继续刚才的讲，现在我们有3个指令了。我们来试试算个（1+4）X2+3吧。</p>
 <div class="highlight">
  <pre><code class="language-text">0100 0001 ；寄存器存入1
0001 0100 ；寄存器的数字加4
0010 0000 ；乘2
0001 0011 ；再加三</code></pre>
 </div>
 <p data-pid="YMctmzMv">太棒了，靠这台计算机我们应该可以打败所有的幼儿园小朋友，称霸大班了。而且现在我们用的是4位的，如果换成8位的CPU完全可以吊打低年级小学生了！</p>
 <p data-pid="m22mwC0D">实际上用程序控制CPU是个挺高级的想法，再此之前计算机（器）的CPU都是单独设计的。</p>
 <p data-pid="kuvuSLzE">1969年一家日本公司BUSICOM想搞程控的计算器，而负责设计CPU的美国公司也觉得每次都重新设计CPU是个挺傻X的事，于是双方一拍即合，于1970年推出一种划时代的产品，世界上第一款微处理器4004。</p>
 <p data-pid="BjuAJyRE">这个架构改变了世界，那家负责设计CPU的美国公司也一步一步成为了业界巨头。哦对了，它叫Intel，对，就是噔噔噔噔的那个。</p>
 <hr>
 <p data-pid="KmYkbBEx">我们把刚才的程序整理一下，</p>
 <div class="highlight">
  <pre><code class="language-text">01000001000101000010000000010011</code></pre>
 </div>
 <p data-pid="bBXdKiE3">你来把它输入CPU，我去准备一下去幼儿园大班踢馆的工作。</p>
 <p data-pid="bn0v9Er4">神马？等我们输完了人家小朋友掰手指都能算出来了？？</p>
 <p data-pid="awduQTyW">没办法机器语言就是这么反人类。哦，忘记说了，这种只有01组成的语言被称之为机器语言（机器码），是CPU唯一可以理解的语言。不过你把机器语言让人读，绝对一秒变典韦，这谁也受不了。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-6aedab3982500ceec8c2c64839e4fef5_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="550" data-rawheight="306" data-original-token="v2-ce30a26417be9e10bceeedff7d43dc24" data-default-watermark-src="https://picx.zhimg.com/50/v2-7ad47880aad47d046507ef1cc972cbd7_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="550" data-original="https://picx.zhimg.com/v2-6aedab3982500ceec8c2c64839e4fef5_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="v09M4GqY">所以我们还是改进一下吧。不过话虽这么讲，也就往前个30年，直接输入01也是个挺普遍的事情。</p>
 <p data-pid="jDl27xlA">于是我们把我们机器语言写成的程序</p>
 <div class="highlight">
  <pre><code class="language-text">0100 0001 ；寄存器存入1
0001 0100 ；寄存器的数字加4
0010 0000 ；乘2
0001 0011 ；再加三</code></pre>
 </div>
 <p data-pid="8L1t2Jlt">改写成</p>
 <div class="highlight">
  <pre><code class="language-text">MOV   1 ；寄存器存入1
ADD   4 ；寄存器的数字加4
SHL   0 ；乘2（介于我们设计的乘法器暂时只能乘2，这个0是占位的）
ADD   3 ；再加三</code></pre>
 </div>
 <p data-pid="6tB2GPIv">是不是容易读多了？这就叫汇编语言。</p>
 <p data-pid="bRf8LKfr">汇编语言的好处在于它和机器语言一一对应。</p>
 <p data-pid="XbaZbaYK">也就是我们写的汇编可以完美的改写成机器语言，直接指挥cpu，进行底层开发；我们也可以把内存中的数据dump出来，以汇编语言的形式展示出来，方便调试和debug。</p>
 <hr>
 <p data-pid="vnM0Xjbl">汇编语言极大的增强了机器语言的可读性和开发效率，但对于人类来说也依然是太晦涩了，于是我们又发明了高级语言，以近似于人类的语法来表现数据结构和算法。</p>
 <p data-pid="ps4rkW9t">比如很多语言都可以这么写：</p>
 <p data-pid="BWio9d4T">a=(1+4)*2+3;</p>
 <p data-pid="KZ-YnzgR">当然这样计算机是不认识的，我们要把它翻译成计算机认识的形式，这个过程叫编译，用来做这个事的东西叫编译器。</p>
 <p data-pid="DpyAyPvn">具体怎么把高级语言弄成汇编语言/机器语言的，一本书都写不完，我们就举个简单的例子。</p>
 <p data-pid="sHeE6QOu">我们把</p>
 <div class="highlight">
  <pre><code class="language-text">(1+4)*2+3</code></pre>
 </div>
 <p data-pid="yVyNKIuJ">转换成</p>
 <div class="highlight">
  <pre><code class="language-text">1，4，+，2，*，3，+</code></pre>
 </div>
 <p data-pid="9iU7yC6H">这种写法叫后缀表示法，也成为逆波兰表示法。相对的，我们平常用的表示法叫中缀表示法，也就是符号方中间，比如1+4。而后缀表示法则写成1，4，+。</p>
 <p data-pid="8p7-xMfz">转换成这种写法的好处是没有先乘除后加减的影响，也没有括号了，直接算就行了。</p>
 <p data-pid="eBADyQnR">具体怎么转换的可以找本讲编译原理的书看看，这里不展开讲了。</p>
 <p data-pid="mQgBrOVG">转换成这种形式之后我们就可以把它改成成汇编语言了。</p>
 <p data-pid="DxpbO8BF">从头开始处理，最开始是1，一个数字，那就存入寄存器。</p>
 <div class="highlight">
  <pre><code class="language-text">MOV  1</code></pre>
 </div>
 <p data-pid="tuKkh_P-">之后是4，+，那就加一下</p>
 <div class="highlight">
  <pre><code class="language-text">ADD  4</code></pre>
 </div>
 <p data-pid="rnS1jZTA">然后是2，*，那就乘一下（介于我们设计的乘法器暂时只能乘2，这个0是占位的）</p>
 <div class="highlight">
  <pre><code class="language-text">SHL  0</code></pre>
 </div>
 <p data-pid="rkAWUQoV">最后是3，+，那再加一下</p>
 <div class="highlight">
  <pre><code class="language-text">ADD  3</code></pre>
 </div>
 <p data-pid="R87RWrRK">最后我们把翻译好的汇编整理一下</p>
 <div class="highlight">
  <pre><code class="language-text">MOV  1
ADD  4
SHL  0
ADD  3</code></pre>
 </div>
 <p data-pid="Ixj7zhVV">再简单的转换成机器语言，就可以拿到我们设计的简单CPU上运行了</p>
 <hr>
 <p data-pid="boHsabf3">其实到了这一步，应该把这个问题都讲清楚了：C语言写出来的东西是怎么翻译成二进制的，电脑又是怎么运行这个二进制的。</p>
 <p data-pid="qrCtUy2T">只不过题主最后还提到栈和硬件的关系，这里就再多说几句。</p>
 <p data-pid="OLkLOqUj">其实栈是一种数据结构，跟CPU无关。只不过栈这个数据结构实在太常用了，以至于CPU会针对性的进行优化。为了能让我们的CPU也能用栈，我们给它增加几个组件。</p>
 <p data-pid="eSt2cM6X">第一，增加一组寄存器。现在有两组寄存器了，我们分别成为A和B。</p>
 <p data-pid="5NQz8d4Q">第二，增加两个指令，RDA/RDB和WRA/WRB，分别为把指定内存地址的数据读到寄存器A/B，和把寄存器A/B的内容写到指定地址。</p>
 <p data-pid="VAe6qVAP">顺便再说下内存，内存有个地址总线，有个数据总线。比如你要把1100这个数字存到0011这个地址，就把1100接到数据总线，0011接到地址总线，都准备好了啪嚓一按开关（对，就是我们前面提到的那个开关），就算是存进去了。</p>
 <p data-pid="GElcCatS">什么叫DDR内存呢，就是你按这个开关的时候存进去一个数字，抬起来之前你把地址和数据都更新一下，然后一松手，啪！又进去一个。也就是正常的内存你按一下进去1个数据，现在你按一下进去俩数据，这就叫双倍速率（Double Data Rate，简称DDR）</p>
 <p data-pid="T49QywXu">加了这几个命令之后我们发现按原来的设计，CPU每个指令针脚控制一个模块的方式的话针脚不够用了。所以我们就需要加一个解码器了（decoder）。</p>
 <p data-pid="Jp2ITK-H">于是我们选择用第二个位作为是否选择寄存器的针脚。如果为0，则第三第四位可以正常激活位移器和加法器；如果为1则只激活寄存器而不激活位移和加法器，然后用第四位来决定是寄存器A还是B</p>
 <p data-pid="DdeUFznz">这样变成了</p>
 <p data-pid="NedtFNCa">0100，数据读入寄存器A</p>
 <p data-pid="aW-0NJ8e">0101，数据读入寄存器B （我们把汇编指令定义为MOVB）</p>
 <p data-pid="04P2SVoc">0001，数据与寄存器A相加，结果保存到寄存器A</p>
 <p data-pid="PJ8IKxtp">0011，数据与寄存器B相加，结果保存到寄存器B（我们把汇编指令定义为ADDB）</p>
 <p data-pid="5_icjY90">0010，寄存器A数据向左位移一位（乘2）</p>
 <p data-pid="KaO0-soh">最后我们可以用第一位来控制是不是进行内存操作。如果第一位为1则也不激活位移和加法器模块，然后用第三个针脚来控制是读还是写。这样就有了</p>
 <p data-pid="uQkIDhrG">1100，把寄存器B的地址数据读入寄存器A（我们把汇编指令定义为RD）</p>
 <p data-pid="RoY57GBF">1110，寄存器A的数据写到寄存器B指定的地址（我们把汇编指令定义为WR）</p>
 <p data-pid="TfySxHqd">我们加了个解码器之后，加法器的激活条件从</p>
 <p data-pid="TdFqtZR1">p4</p>
 <p data-pid="YuRVVBRk">变成了</p>
 <p data-pid="oRxOZ-Gc">(NOT (p1 OR p2)) AND p4</p>
 <p data-pid="8B74T4XP">加法器的输入则由第三个针脚判断，0则为寄存器A，1为寄存器B</p>
 <p data-pid="a110mGgO">这就是简单的指令解码啦。</p>
 <p data-pid="DUVMLnrJ">当然我们也可以选择不向下兼容，另外设计一套指令。不过放到现实世界恐怕就要出大乱子了，所以你也可以想象我们平常用的x86背了个多大的历史包袱。</p>
 <hr>
 <p data-pid="vMtbXniP">这个时候我们用栈的话，先栈地址初始化</p>
 <div class="highlight">
  <pre><code class="language-text">0101 1000 ; MOVB 16; 把栈底地址定义为1000</code></pre>
 </div>
 <p data-pid="fRCJIyvq">之后入栈的话，比如把数字3,4入栈</p>
 <div class="highlight">
  <pre><code class="language-text">1111 0011 ; WR   03; 把3写到内存，地址为1000
0011 0001 ; ADDB 01; 栈地址+1 
1111 0100 ; WR   04; 把3写到内存，地址为1001
0011 0001 ; ADDB 01; 栈地址+1 </code></pre>
 </div>
 <p data-pid="FyuewqpY">这样就把3，4都保存到栈里了。</p>
 <p data-pid="YCLEXc9W">出栈的话反过来</p>
 <div class="highlight">
  <pre><code class="language-text">0011 1111 ; ADDB -1; 栈地址-1
1101 0000 ; RD   00; 把内容读入寄存器A，00是占位
0011 1111 ; ADDB -1; 栈地址-1
1101 0000 ; RD   00; 把内容读入寄存器A，00是占位 </code></pre>
 </div>
 <p data-pid="6vBRE3QF">这样就依次得到4，3两个值。</p>
 <p data-pid="Fxk5l5aE">所以，入栈出栈其实就是把数据写道指定的内存位置，CPU其实不知道你是在干啥。</p>
 <p data-pid="r9VROckZ">当然我们也可以让CPU知道。</p>
 <p data-pid="clN0TdbE">接下来我们再改进一下，给CPU再加一个寄存器SP，并定义两个指令：一个PUSH，一个POP。动作分别是把数据写入SP的地址，然后SP=SP+1，POP的话反过来。</p>
 <p data-pid="fMYHckic">这样有什么好处呢？好处在于PUSH/POP这样的指令消耗特别少，速度特别快。而栈这种数据结构在各种程序里用的又特别频繁，设计成专用的指令则可以很大程度上提升效率。</p>
 <p data-pid="E9SeJPwl">当然前提是编译器知道这个指令，并且做了优化，所以同样的程序（c语言写的），编译参数不一样（打开/关闭某些特性），编译出来的东西也就不一样，在不同硬件上的运行的效率也就会不一样。</p>
 <p data-pid="JQvTubnq">比如上古时代的mmx，今天的SSE4.2，AVX-512，给力不给力？特别给力，但你平常用的程序支不支持是另一码事，要支持怎么办？重新编译呗。</p>
 <p data-pid="LcatHV2z">这个时候开源的优势就显示出来了，重新编译很方便。闭源的话你就要指望作者开恩啦。</p>
 <hr>
 <p data-pid="MtTTJZp2">结语：</p>
 <p data-pid="kgoVwIuL">多谢大家捧场，断断续续更了一周，终于算是更完了。</p>
 <p data-pid="kSONjbU-">对于大多数人来说，电脑就是个黑箱，我们很难理解它到底是怎用工作的。这个问题又很难一句两句解释清楚，因为它是一环扣一环的，每一环都很抽象，每一环都是基础值俩个学分，展开了讲没上限的那种。</p>
 <p data-pid="Ab1z1tmZ">这就导致了即使是系统学过计算机的人也不见得就有一个明确而清晰的思路。</p>
 <p data-pid="xsok1zst">所以借着这个机会，想用尽量短的篇幅和尽量简单的语言把这个事从头到位解释了一下，希望能给大家解答一些疑惑。结果写完之后发现也还是写了长长的一篇。能读到底的都是猛士，再次谢谢大家捧场。</p>
 <p data-pid="gcUAnDHT">最后，行文匆忙，接下来会把之前的各种小错改一改，有什么问题也可以在评论里提出来哈。</p>
</body>