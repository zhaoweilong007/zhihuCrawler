# 在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进？
- 点赞数：6288
- 更新时间：2020年12月17日00时57分43秒
- 回答url：https://www.zhihu.com/question/68611994/answer/298845862
<body>
 <p data-pid="6kTu_RXt">update：抱歉了各位，列书单和介绍的计划可能要鸽了… 一方面由于很多书都找不到了；另外就是很多我当时读的书，现在都有更好的替代技术或讲的更好的书；最后的原因就是懒… 一次把所有东西写出来太累了。</p>
 <p data-pid="m_KgS-VF">不过我会把觉得值得推荐或者我最近看的书和论文简介在下边这两个专栏里，有兴趣的同学可以关注下 ( ^ω^ )</p><a data-draft-node="block" data-draft-type="link-card" href="https://zhuanlan.zhihu.com/c_212000558" class="internal"><span class="invisible">https://</span><span class="visible">zhuanlan.zhihu.com/c_21</span><span class="invisible">2000558</span><span class="ellipsis"></span></a><a data-draft-node="block" data-draft-type="link-card" href="https://zhuanlan.zhihu.com/c_158208519" class="internal"><span class="invisible">https://</span><span class="visible">zhuanlan.zhihu.com/c_15</span><span class="invisible">8208519</span><span class="ellipsis"></span></a>
 <p data-pid="4tS7i-hM">以下原答案：</p>
 <hr>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="h-zzBDbW">在我目前10年的程序员道路上，让我感到自己质变了的，有大彻大悟的感觉的，是：一本书，和2个概念/技术/领域/...吧。分别对应<b>我所认为</b>的程序员能力对应的三个关键方面。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <h2>1书2概念</h2>
 <ol>
  <li data-pid="KlutYx2k"><b>一本书</b>：<b>Designing Data-Intensive Applications， </b>对应程序员3能力中的<b>工具箱深度广度</b></li>
  <li data-pid="LauhaW0u"><b>两个概念-1：多范式编程和最小表达力原则(least expressiveness principle), </b>对应程序员3能力中的<b>程序语言理解深度和表达抽象能力</b></li>
  <li data-pid="bPzIJQvs"><b>两个概念-2：领域驱动设计(Domain Driven Design)，</b>对应程序员3能力中的<b>方法论，编程大道(programming in the big)，和构架能力</b></li>
 </ol>
 <p class="ztext-empty-paragraph"><br></p>
 <h2><b>关于程序员3能力</b>：（引自自己的一个答案：<a href="https://www.zhihu.com/question/264728220/answer/285385281" class="internal">阿莱克西斯：作为一名程序员，我这属于什么水平？</a>）</h2>
 <blockquote data-pid="9vNsbpIa">
  <b>1. 工具箱广度深度</b>，或者说在技术选型上控制系统复杂度的能力，广度：懂多少数据库/数据处理框架/AWS几个重要的Service了解多少/著名的开源软件框架工具了解程度, （这个一年前的答案列了一些我们当时经常用的，业界也很流行的，您可以参考下。<a href="https://www.zhihu.com/question/40629707/answer/109764896" class="internal">阿莱克西斯：后端所谓复杂的问题是什么？</a> ） 广度决定了眼界； 深度：为什么数据库要这么实现设计，为什么AWS这个地方有这个缺陷（比如SQS为什么是可乱序的queue），看似类似的几个框架，在本质上有什么不同，是在哪个本质问题上做了哪些决定行的trade-off导致了它们在设计实现和提供的功能上分道扬镳？ 深度决定了能否真的在合适的场景应用合适的能力与工具。
  <br>
  <br><b>2. 程序语言理解深度和表达抽象能力，</b>这是在实现上控制复杂度的能力，懂不懂得最小表达力原则？懂得几种编程范式？它们之间怎么根据具体情况作出取舍？是否知道怎样才能把code写成诗？怎么样才能在重重困难中，坚守高聚合，低耦合？怎样组织程序，才能使得让程序正向流动产生期待效果之外，程序能否根据效果／结果，倒推并很容易的倒推出这样的一种结果是由什么原因，那个组件造成的(这是系统怎么才能很容易进化的关键，也是“做出来就是好的”程序员最难克服的一点)？code写出来逻辑线是否清晰可见？<a href="https://www.zhihu.com/question/22508677/answer/276595266" class="internal">阿莱克西斯：编程到底难在哪里？</a> (
  <br>
  <br>
  <br><b>3. 方法论，编程大道(programming in the big)，和构架能力</b>，这是在时间跨度的整体上控制复杂度的能力，辨别什么是对的，应该做什么的能力；在时间跨度上，在信息不完整的情况下，现在怎么构架，才能使得当将来信息完整了，我们能很轻松的根据将来的正确信息，把系统调整成最好最正确的状态，什么决定应该现在做，什么决定可以和怎么样才能留给将来做，并且在这个过程中，保证能够支持业务正常运转。在整体上，怎么把需求获取/设计/coding/测试/安全/部署/运行监测/报警/性能/系统回馈分析/数据统计/报表…等等在全局把握，安排的妥妥当当相互支持而不是相互抵触，相互使绊子。这里包含的知识包括，到底是waterfall， TDD，BDD，还是type driven，怎么执行Agile，什么是devOps，continuous delivery。 到底应该是技术决定业务，还是业务决定技术？。给一个100人的团队和超复杂／抽象的需求（比如需求就是让公司业务翻一倍，怎么翻一倍这个抽象问题要怎么分解成n个大问题，这n个大问题怎么分解成m个中问题。。。。），怎么把抽象问题落到实处，怎么能把大的问题分解成哪怕是比较弱的程序员也可以解决的小问题，然后还要证明这是根据现在的信息，可以做出的最好的决定。<a href="https://www.zhihu.com/question/263874795" class="internal">2017年，你看了啥很好的计算机的博客/书/视频？</a> 这个回答中关于DDD和Clean Architecture的介绍讨论了一些这方面的问题您可以看下。
 </blockquote>
 <p data-pid="zNVTWk0g">可以看到，这3个能力有一个相同的关键点，<b>控制复杂度；</b>控制复杂度的能力，是区分程序员能力的关键之一。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <h2>为什么是这本书， 这两个概念，是什么质变：</h2>
 <ol>
  <li data-pid="j_sGanOS">关于一书：<b>Designing Data-Intensive Applications： </b>由于我的主要工作是利用云技术，做后端的大数据模型，或者高性能，高弹性，高可用性的service，所以数据处理，和云技术是我工具箱里最重要的一部分工具。我之前比较深入的（内部怎么工作的深度，每个系统至少读过一本书，有一些看过源代码）学过Oracle, HBase, Cassandra, Redshift, Hadoop, Spark Kafka, Storm, Zookeeper...Amazon自己的DynamoDB, Kinesis, SQS／SNS, AWS Lambda, Step Function, SimpleWorkflow, EMR... 但是我的学习是像没头苍蝇一样的，是盲目的，哪个技术火，就学哪个，总觉得这些东西之间模模糊糊的是有联系的，感觉是有一些东西是可以总结起来的。。。脑子里或者说工具箱里里的东西很多，但是却非常乱，概念实现经常记混，我经常在想：<b>如果能总结归类，用更科学的方法去记住所有我学过的技术，那就好了。。。</b>然后我就遇到了这本书，我读了三遍，然后感觉一切都理顺了… 如果我先读了这本书，才去学上边这些东西，那么我花费的时间将是原来的3分之一到5分之一左右。这本书在广度和一定程度的深度（如果对进一步深度有要求，可以读完此书的reference）上，概括和总结了数据系统，分布式或非分布式环境下面临的本质问题，和解决方案的分类，看完这本，我开始理解了“为什么”这么多的分布式系统要这么设计。而这本书上千的引用论文，给我指明了一条系统学习理论的明路。</li>
  <li data-pid="6dG29VFL">关于<b>多范式编程和最小表达力原则(least expressiveness principle)：</b>学了好多语言，设计模式，AOP，范型，反射，DCI。。。不知什么时候起，我已经忘记了我为什么要学习他们了，我的程序开始变成一个程序员的行为艺术，简直可谓花式编程。怎么样能用别人都不懂的花式技术秀翻全组，变成了我觉得可以体现我的学识的关键。。。（在这里要跟接手和维护我花式行为艺术的同学深深的道歉。。。）直到我了解到了多范式编程(Multi-Paradigm Programming)和最小表达力原则(least expressiveness principle), 我才中混沌中惊醒<b>，</b>回归初心，<b>简化程序，用尽可能简单的程序来解决尽可能复杂的问题，才是我们发明和学习了这么多技术的最终目的啊！</b></li>
  <li data-pid="oDuQOeGT"><b>关于领域驱动设计(Domain Driven Design)：</b>从具体的大处来说，它让我明白了“为什么要有程序员”，这个话题很大很抽象，下边的引用有一些详述。 从小的来说，它让我懂得了怎么样用系统的方法来设计系统，实现系统，从而让VP，Director，各级开发经理, 产品经理，客户，和我们组配合的机器学习科学家，统计学家，经济学家，他们脑子里的系统，和我们程序员的code的组织，系统的组件设计实现，能够有一个清晰的对应，且这个清晰的对应，如何在无数的需求改变，无数的技术升级中，在长期的时间跨度上，如何能够坚守住，如何持续保证概念模型(concept model)和实现模型(implementation model)的一致，并且是清晰一致。那么，一个小的脑子里的模型改动，必然只会引起一个系统的小的改动。做到这点<b>，是在长远的时间角度，在考虑了未知的未来，考虑了明天的你，团队，客户，都会收到新的未知的信息的情况下(而不是根据一个时间点的需求)保持一个健康，可业务拓展，有竞争力的，能够成为组部门公司之脊梁的系统的关键！</b>用比喻义来说：如果说<b>Designing Data-Intensive Applications</b>是逍遥子百年功力，是莽牯朱蛤，是张无忌吃的昆仑山蟠桃，给你无穷的内力，那么这些方法论则是北冥神功，九阳神功，易筋经，教你如何驾驭这力量，而不是自爆而亡。</li>
 </ol>
 <blockquote data-pid="WLJOHmzR">
  为什么传统行业不断被颠覆？为什么人工持续被计算机代替？程序员，拿着大杀器，以更科学更效率的新方法，解决了更多更大更新的问题，这当然需要程序员非常了解你手中这个大杀器；然而首先，你要明白，<b>自己的价值，在于你是一个解决问题的人。</b>
  <br>
   ----<a href="https://www.zhihu.com/question/37093538/answer/115426434" class="internal">阿莱克西斯：对于程序员来说，怎样才算是在写有“技术含量”的代码？</a>
 </blockquote>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <h2>DDD的精神</h2>
 <p data-pid="pinCh-S3"><i>私信和某位朋友聊了一会儿DDD，自己也想了很多，贴一些在这里：</i></p>
 <p data-pid="s7rssjvy">再多说点DDD吧，请千万不要看网上鱼龙混杂的资料，很多博主自己还没明白就写各种怎么做EventSourcing，怎么做CQRS的文章，说这是DDD构架，DDD就必须得怎么怎么样，这些都反而是违反DDD的精神的，想了解DDD，请千万去读一本关于DDD的书，而我强烈推荐推荐Patterns, Principles, and Practices of Domain-Driven Design 而不是Evans的原版。</p>
 <p data-pid="gXqf6bAS">一个DDD 实践者经常使用的重要的practise，就是跟PM和客户讨价还价, 学会拒绝和剪裁，合理的push back，也是我面试Sr. SDE时候会考察的软技能之一</p>
 <p data-pid="oFcwn55Z">因为复杂的技术实现是有代价的，要看换来的业务价值是什么，如果核心逻辑要求一个技术实现，关系到项目的成败，那就要不惜代价的去选择完备的实现方案。而当一个超复杂的技术实现只是为了一个可有可无的业务功能，那就要强势说服客户PM砍掉这个功能。因为支持这个功能造成系统的复杂度，可能会给拓展核心业务造成困难。</p>
 <p data-pid="kwW2unSr">这里推荐一下Worse is better这篇文章，论述了为什么简单大于一切。</p>
 <ol>
  <li data-pid="LI2MFccu">简单要大于正确性，因为现在的正确未必是未来的正确，砍掉意义不大的正确性，保持核心的简单性，是让核心能够轻装上阵，更好演化的关键。</li>
  <li data-pid="gNix1HQT">简单大于一致性，这个很多例子了，大家从事务的强一致行转为prefer 最重一致性就是在这点上trade off的最好例子</li>
  <li data-pid="xlv74iI5">简单大于功能完备性，这个上边我也解释过了。不需要非核心的功能完备性而牺牲核心或者系统的整体简单性。</li>
 </ol>
 <p data-pid="W_K8NC-2">那么怎么在简单，业务正确性，一致性，完备性里，做合理的trade-off（因为完全不要正确性，一致性和完备性也不行呀）就需要对业务有深入的了解认识。程序员的本质还是解决问题的人，只是恰巧用计算机来解决问题而已，好的程序员是<b>简化问题和解决问题的高手</b>，他能够在业务/技术/人员/文化/复杂度/等等多角度做剪裁，来衡量各种得失，而不是把自己逼死累死在复杂的技术实现上，用灵活的手段来让自己的组和公司获得成功。</p>
 <p data-pid="JBrse646"><b>跳出技术思维的束缚，从全局来思考问题，我想，这就是DDD的精神吧。</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <h2>尾</h2>
 <p data-pid="rXpDPp_9">我是一个数学系，全自学转行计算机的程序员(因为真的喜欢这行，直到现在也是很经常看书或论文到夜里1点)，现在在Amazon西雅图的一个负责后端黑魔法，做智能优化决策的部门里担任tech leader，最近正在写一篇我这10年里如何自学的文章，主要会讲：</p>
 <ol>
  <li data-pid="AYOLlinK">我看过的书的列表和书评，</li>
  <li data-pid="iSilUW4q">推荐的阅读顺序(我觉得这个对自学真的太重要了，在没有必要的铺垫知识的情况下，去读很深入的书，效率非常非常低），</li>
  <li data-pid="JOCcqOOX">那些年我踩过的那些坑。。。</li>
  <li data-pid="O9pDv7EM">对于有争议的技术的我的看法，和一些我强烈建议不要去学的（真的浪费了我很多生命），在被淘汰的路上的，而还有很多人在吹的东西。</li>
 </ol>
 <p data-pid="WV88q97e">自学的路是孤独的，走去了弯路是痛苦的，丢失了方向是迷茫的，看不懂书对自己的智商是质疑的，这里边的苦，我很明白。所以希望自己的这条路径可以当作大家的一个参考，提供一点点帮助。（来看看自学10年的人的心里的苦：<a href="https://www.zhihu.com/question/67815363/answer/257645590" class="internal">阿莱克西斯：真正“自学”入门编程/程序员是一种怎样的体验？</a>）</p>
 <p data-pid="DSGjA7Rq">自学计算机的，和即使毕业也在学习计算机的小盆友可以关注一下哟⁄(⁄ ⁄ ⁄ω⁄ ⁄ ⁄)⁄ ，还没确定用什么平台写，不过文章发出后我会用想法通知关注的大家。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="5dYjEt0d">欢迎催稿 （这里有一个懒惰的表情）</p>
 <p data-pid="o1tfCSUj">连赞都不点的人没资格催稿…（咩 —_—</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="oaiSqxnL">(￣∇￣)</p>
 <p></p>
 <p></p>
</body>