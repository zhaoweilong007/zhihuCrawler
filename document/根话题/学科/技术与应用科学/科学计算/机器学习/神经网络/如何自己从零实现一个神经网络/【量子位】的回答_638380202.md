# 如何自己从零实现一个神经网络?
- 点赞数：7329
- 更新时间：2019年04月01日18时11分42秒
- 回答url：https://www.zhihu.com/question/314879954/answer/638380202
<body>
 <p data-pid="he369D2w">“我在网上看到过很多神经网络的实现方法，但这一篇是最简单、最清晰的。”</p>
 <p data-pid="3C4NUZ_I">一位来自普林斯顿的华人小哥Victor Zhou，写了篇神经网络入门教程，在线代码网站Repl.it联合创始人Amjad Masad看完以后，给予如是评价。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-99e054b2f05f86cad74ca594309d0257_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="916" data-rawheight="208" data-original-token="v2-99e054b2f05f86cad74ca594309d0257" class="origin_image zh-lightbox-thumb" width="916" data-original="https://pic1.zhimg.com/v2-99e054b2f05f86cad74ca594309d0257_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="V1d0kFzW">这篇教程发布仅天时间，就在Hacker News论坛上收获了574赞。程序员们纷纷夸赞这篇文章的代码写得很好，变量名很规范，让人一目了然。</p>
 <p data-pid="MzuYie0B">下面就让我们一起从零开始学习神经网络吧。</p>
 <h2><b>实现方法</b></h2>
 <h3><b>搭建基本模块——神经元</b></h3>
 <p data-pid="So88WQj0">在说神经网络之前，我们讨论一下<b>神经元</b>（Neurons），它是神经网络的基本单元。神经元先获得输入，然后执行某些数学运算后，再产生一个输出。比如一个2输入神经元的例子：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-5550feac69724dcbc145574525ae42f6_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="350" data-original-token="v2-5550feac69724dcbc145574525ae42f6" class="origin_image zh-lightbox-thumb" width="600" data-original="https://picx.zhimg.com/v2-5550feac69724dcbc145574525ae42f6_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="9zXlCCoy">在这个神经元中，输入总共经历了3步数学运算，</p>
 <p data-pid="VrUTa1lT">先将两个输入乘以<b>权重</b>（weight）：</p>
 <p data-pid="9VeVlESd">x1→x1 × w1<br>
  x2→x2 × w2</p>
 <p data-pid="7pirnSkf">把两个结果想加，再加上一个<b>偏置</b>（bias）：</p>
 <p data-pid="dLnHnv_z">（x1 × w1）+（x2 × w2）+ b</p>
 <p data-pid="JYZv8fU8">最后将它们经过<b>激活函数</b>（activation function）处理得到输出：</p>
 <p data-pid="rz73cf82">y = f(x1 × w1 + x2 × w2 + b)</p>
 <p data-pid="W9UtgZpI">激活函数的作用是将无限制的输入转换为可预测形式的输出。一种常用的激活函数是sigmoid函数：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-7ac6165a27e42e2642d399272db1396c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="721" data-original-token="v2-7ac6165a27e42e2642d399272db1396c" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://picx.zhimg.com/v2-7ac6165a27e42e2642d399272db1396c_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Y_j6fvmP">sigmoid函数的输出介于0和1，我们可以理解为它把 (−∞,+∞) 范围内的数压缩到 (0, 1)以内。正值越大输出越接近1，负向数值越大输出越接近0。</p>
 <p data-pid="aWPfFMu-">举个例子，上面神经元里的权重和偏置取如下数值：</p>
 <p data-pid="_E-YKsxj">w=[0,1]<br>
  b = 4</p>
 <p data-pid="RQRNGEt9">w=[0,1]是w1=0、w2=1的向量形式写法。给神经元一个输入x=[2,3]，可以用向量点积的形式把神经元的输出计算出来：</p>
 <p data-pid="UYN8qHvO">w·x+b =（x1 × w1）+（x2 × w2）+ b = 0×2+1×3+4=7<br>
  y=f(w⋅X+b)=f(7)=0.999</p>
 <p data-pid="yRW6SwTP">以上步骤的Python代码是：</p>
 <div class="highlight">
  <pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="c1"># Our activation function: f(x) = 1 / (1 + e^(-x))</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Neuron</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">bias</span>

  <span class="k">def</span> <span class="nf">feedforward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
    <span class="c1"># Weight inputs, add bias, then use the activation function</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span>
    <span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># w1 = 0, w2 = 1</span>
<span class="n">bias</span> <span class="o">=</span> <span class="mi">4</span>                   <span class="c1"># b = 4</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">Neuron</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>       <span class="c1"># x1 = 2, x2 = 3</span>
<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>    <span class="c1"># 0.9990889488055994</span></code></pre>
 </div>
 <p data-pid="zTwhhvpG">我们在代码中调用了一个强大的Python数学函数库<b>NumPy</b>。<br></p>
 <h3><b>搭建神经网络</b></h3>
 <p data-pid="zSggxCju">神经网络就是把一堆神经元连接在一起，下面是一个神经网络的简单举例：</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-6dd1407c23fe6950351fcbb47cb4ecdc_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="550" data-rawheight="250" data-original-token="v2-6dd1407c23fe6950351fcbb47cb4ecdc" class="origin_image zh-lightbox-thumb" width="550" data-original="https://pic1.zhimg.com/v2-6dd1407c23fe6950351fcbb47cb4ecdc_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="TqbP0Yib">这个网络有2个输入、一个包含2个神经元的隐藏层（h1和h2）、包含1个神经元的输出层o1。<br></p>
 <p data-pid="GvZXDcEi">隐藏层是夹在输入输入层和输出层之间的部分，一个神经网络可以有多个隐藏层。</p>
 <p data-pid="jnn8ZzAf">把神经元的输入向前传递获得输出的过程称为<b>前馈</b>（feedforward）。</p>
 <p data-pid="jewFGQ6H">我们假设上面的网络里所有神经元都具有相同的权重w=[0,1]和偏置b=0，激活函数都是sigmoid，那么我们会得到什么输出呢？</p>
 <p data-pid="OGlxdMMi">h1=h2=f(w⋅x+b)=f((0×2)+(1×3)+0)<br>
  =f(3)<br>
  =0.9526</p>
 <p data-pid="TMjkzhaP">o1=f(w⋅[h1,h2]+b)=f((0∗h1)+(1∗h2)+0)<br>
  =f(0.9526)<br>
  =0.7216</p>
 <p data-pid="PMlGx9bY">以下是实现代码：</p>
 <div class="highlight">
  <pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># ... code from previous section here</span>

<span class="k">class</span> <span class="nc">OurNeuralNetwork</span><span class="p">:</span>
  <span class="s1">'''
</span><span class="s1">  A neural network with:
</span><span class="s1">    - 2 inputs
</span><span class="s1">    - a hidden layer with 2 neurons (h1, h2)
</span><span class="s1">    - an output layer with 1 neuron (o1)
</span><span class="s1">  Each neuron has the same weights and bias:
</span><span class="s1">    - w = [0, 1]
</span><span class="s1">    - b = 0
</span><span class="s1">  '''</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">bias</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># The Neuron class here is from the previous section</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">h1</span> <span class="o">=</span> <span class="n">Neuron</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">h2</span> <span class="o">=</span> <span class="n">Neuron</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">o1</span> <span class="o">=</span> <span class="n">Neuron</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">feedforward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">out_h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">out_h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h2</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># The inputs for o1 are the outputs from h1 and h2</span>
    <span class="n">out_o1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o1</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">out_h1</span><span class="p">,</span> <span class="n">out_h2</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">out_o1</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">OurNeuralNetwork</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># 0.7216325609518421</span></code></pre>
 </div>
 <h3><b>训练神经网络</b></h3>
 <p data-pid="GPHt3xT4">现在我们已经学会了如何搭建神经网络，现在我们来学习如何训练它，其实这就是一个优化的过程。</p>
 <p data-pid="KsCOYFnb">假设有一个数据集，包含4个人的身高、体重和性别：</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-f15a751a4c95d116aff1cbe66e85e2df_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="280" data-original-token="v2-f15a751a4c95d116aff1cbe66e85e2df" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://picx.zhimg.com/v2-f15a751a4c95d116aff1cbe66e85e2df_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="JBlcpSiN">现在我们的目标是训练一个网络，根据体重和身高来推测某人的性别。</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-b9ee7f111417a4c4e4dcc5e814667e09_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="550" data-rawheight="250" data-original-token="v2-b9ee7f111417a4c4e4dcc5e814667e09" class="origin_image zh-lightbox-thumb" width="550" data-original="https://picx.zhimg.com/v2-b9ee7f111417a4c4e4dcc5e814667e09_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="bsm_mDC8">为了简便起见，我们将每个人的身高、体重减去一个固定数值，把性别男定义为1、性别女定义为0。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-463fc37c108236a0f571b09c3184dbf6_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="280" data-original-token="v2-463fc37c108236a0f571b09c3184dbf6" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://picx.zhimg.com/v2-463fc37c108236a0f571b09c3184dbf6_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="6gz82mgG">在训练神经网络之前，我们需要有一个标准定义它到底好不好，以便我们进行改进，这就是<b>损失</b>（loss）。</p>
 <p data-pid="Ggkw3pwt">比如用<b>均方误差</b>（MSE）来定义损失：<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-1471c8a0328fd909137892a88dfec354_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="153" data-original-token="v2-1471c8a0328fd909137892a88dfec354" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-1471c8a0328fd909137892a88dfec354_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="bBmt0z29">n是样本的数量，在上面的数据集中是4；<br>
  y代表人的性别，男性是1，女性是0；<br>
  ytrue是变量的真实值，ypred是变量的预测值。</p>
 <p data-pid="-eQCEV4j">顾名思义，均方误差就是所有数据方差的平均值，我们不妨就把它定义为损失函数。预测结果越好，损失就越低，<b>训练神经网络就是将损失最小化。</b></p>
 <p data-pid="vGN-kBoA">如果上面网络的输出一直是0，也就是预测所有人都是男性，那么损失是：<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-b80d6824424193c22835b3814a82ebf5_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="281" data-original-token="v2-b80d6824424193c22835b3814a82ebf5" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-b80d6824424193c22835b3814a82ebf5_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="mN4U34LD"><b>MSE= 1/4 (1+0+0+1)= 0.5</b></p>
 <p data-pid="qPEG-kUb">计算损失函数的代码如下：<br></p>
 <div class="highlight">
  <pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">mse_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
  <span class="c1"># y_true and y_pred are numpy arrays of the same length.</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">mse_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span> <span class="c1"># 0.5</span></code></pre>
 </div>
 <h3><b>减少神经网络损失</b><br></h3>
 <p data-pid="EgylX7no">这个神经网络不够好，还要不断优化，尽量减少损失。我们知道，改变网络的权重和偏置可以影响预测值，但我们应该怎么做呢？</p>
 <p data-pid="9kxOxjDm">为了简单起见，我们把数据集缩减到只包含Alice一个人的数据。于是损失函数就剩下Alice一个人的方差：<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-607474125bb8f8fd26606eaa6b823d9d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="297" data-original-token="v2-607474125bb8f8fd26606eaa6b823d9d" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://picx.zhimg.com/v2-607474125bb8f8fd26606eaa6b823d9d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="hM483SzC">预测值是由一系列网络权重和偏置计算出来的：<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-1bc3b1c2be12eec72acfc953a7bac37d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="550" data-rawheight="250" data-original-token="v2-1bc3b1c2be12eec72acfc953a7bac37d" class="origin_image zh-lightbox-thumb" width="550" data-original="https://pic1.zhimg.com/v2-1bc3b1c2be12eec72acfc953a7bac37d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="2qU3wqy5">所以损失函数实际上是包含多个权重、偏置的多元函数：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-db41b32acd686d37c28c769259e0ad91_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="85" data-original-token="v2-db41b32acd686d37c28c769259e0ad91" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-db41b32acd686d37c28c769259e0ad91_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ianpXi5c">（注意！前方高能！需要你有一些基本的多元函数微分知识，比如偏导数、链式求导法则。）<br></p>
 <p data-pid="9rdeqg3e">如果调整一下w1，损失函数是会变大还是变小？我们需要知道偏导数∂L/∂w1是正是负才能回答这个问题。</p>
 <p data-pid="zNzU_S6h">根据链式求导法则：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-e66542108055988b3a1df8d556e2d11d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="141" data-original-token="v2-e66542108055988b3a1df8d556e2d11d" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://picx.zhimg.com/v2-e66542108055988b3a1df8d556e2d11d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="hPlUnOV7">而L=(1-ypred)2，可以求得第一项偏导数：</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-252af9e26b84b8ac4777e84a2799f57c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="125" data-original-token="v2-252af9e26b84b8ac4777e84a2799f57c" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-252af9e26b84b8ac4777e84a2799f57c_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="0r3dUroE">接下来我们要想办法获得ypred和w1的关系，我们已经知道神经元h1、h2和o1的数学运算规则：<br></p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-fce5cec5e9477239784768d75fc97530_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="105" data-original-token="v2-fce5cec5e9477239784768d75fc97530" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pica.zhimg.com/v2-fce5cec5e9477239784768d75fc97530_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ategHwwV">实际上只有神经元h1中包含权重w1，所以我们再次运用链式求导法则：<br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-1bee04eaf0dea89d1708998ac81dc378_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="245" data-original-token="v2-1bee04eaf0dea89d1708998ac81dc378" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-1bee04eaf0dea89d1708998ac81dc378_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="8F17mskr">然后求∂h1/∂w1</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-70aa49b8d152d7984a0d993d2291a0bb_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="221" data-original-token="v2-70aa49b8d152d7984a0d993d2291a0bb" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-70aa49b8d152d7984a0d993d2291a0bb_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="hRDXgnTj">我们在上面的计算中遇到了2次激活函数sigmoid的导数f′(x)，sigmoid函数的导数很容易求得：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-d41dc8afcf6fb553d66dbad24758fe9a_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="274" data-original-token="v2-d41dc8afcf6fb553d66dbad24758fe9a" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pica.zhimg.com/v2-d41dc8afcf6fb553d66dbad24758fe9a_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="dlhIPbB0">总的链式求导公式：<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-ee978cf040e5582b799ac3bcfcfc0cb1_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1068" data-rawheight="172" data-original-token="v2-ee978cf040e5582b799ac3bcfcfc0cb1" class="origin_image zh-lightbox-thumb" width="1068" data-original="https://picx.zhimg.com/v2-ee978cf040e5582b799ac3bcfcfc0cb1_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="L7FM0reM">这种向后计算偏导数的系统称为<b>反向传播</b>（backpropagation）。</p>
 <p data-pid="akaqHrTn">上面的数学符号太多，下面我们带入实际数值来计算一下。h1、h2和o1</p>
 <p data-pid="eojEDEVv">h1=f(x1⋅w1+x2⋅w2+b1)=0.0474</p>
 <p data-pid="uZrPIiHL">h2=f(w3⋅x3+w4⋅x4+b2)=0.0474</p>
 <p data-pid="74MmC_uf">o1=f(w5⋅h1+w6⋅h2+b3)=f(0.0474+0.0474+0)=f(0.0948)=0.524</p>
 <p data-pid="QpaqM5_5">神经网络的输出y=0.524，没有显示出强烈的是男（1）是女（0）的证据。现在的预测效果还很不好。</p>
 <p data-pid="5zt_xhvR">我们再计算一下当前网络的偏导数∂L/∂w1：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-4ab9796eea7123ad708e268c4e7b9448_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="992" data-rawheight="1242" data-original-token="v2-4ab9796eea7123ad708e268c4e7b9448" class="origin_image zh-lightbox-thumb" width="992" data-original="https://pica.zhimg.com/v2-4ab9796eea7123ad708e268c4e7b9448_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="mdYk-k-y">这个结果告诉我们：如果增大w1，损失函数L会有一个非常小的增长。</p>
 <h3><b>随机梯度下降</b></h3>
 <p data-pid="b5qJlVzD">下面将使用一种称为<b>随机梯度下降</b>（SGD）的优化算法，来训练网络。</p>
 <p data-pid="GCFRY0dk">经过前面的运算，我们已经有了训练神经网络所有数据。但是该如何操作？SGD定义了改变权重和偏置的方法：</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-22118be9602e08f7320ee1a3b7aee998_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="744" data-rawheight="178" data-original-token="v2-22118be9602e08f7320ee1a3b7aee998" class="origin_image zh-lightbox-thumb" width="744" data-original="https://pic1.zhimg.com/v2-22118be9602e08f7320ee1a3b7aee998_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="7yUuIInc">η是一个常数，称为<b>学习率</b>（learning rate），它决定了我们训练网络速率的快慢。将w1减去η·∂L/∂w1，就等到了新的权重w1。<br></p>
 <p data-pid="3gs6KjeN">当∂L/∂w1是正数时，w1会变小；当∂L/∂w1是负数 时，w1会变大。</p>
 <p data-pid="Y1eb0RgH">如果我们用这种方法去逐步改变网络的权重w和偏置b，损失函数会缓慢地降低，从而改进我们的神经网络。</p>
 <p data-pid="40HPZLM-">训练流程如下：</p>
 <p data-pid="WDqcIXqD">1、从数据集中选择一个样本；<br>
  2、计算损失函数对所有权重和偏置的偏导数；<br>
  3、使用更新公式更新每个权重和偏置；<br>
  4、回到第1步。</p>
 <p data-pid="5AMjKXLR">我们用Python代码实现这个过程：</p>
 <div class="highlight">
  <pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="c1"># Sigmoid activation function: f(x) = 1 / (1 + e^(-x))</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deriv_sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="c1"># Derivative of sigmoid: f'(x) = f(x) * (1 - f(x))</span>
  <span class="n">fx</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mse_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
  <span class="c1"># y_true and y_pred are numpy arrays of the same length.</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">OurNeuralNetwork</span><span class="p">:</span>
  <span class="s1">'''
</span><span class="s1">  A neural network with:
</span><span class="s1">    - 2 inputs
</span><span class="s1">    - a hidden layer with 2 neurons (h1, h2)
</span><span class="s1">    - an output layer with 1 neuron (o1)
</span><span class="s1">
</span><span class="s1">  *** DISCLAIMER ***:
</span><span class="s1">  The code below is intended to be simple and educational, NOT optimal.
</span><span class="s1">  Real neural net code looks nothing like this. DO NOT use this code.
</span><span class="s1">  Instead, read/run it to understand how this specific network works.
</span><span class="s1">  '''</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Weights</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w6</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>

    <span class="c1"># Biases</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">feedforward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># x is a numpy array with 2 elements.</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">)</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w3</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">)</span>
    <span class="n">o1</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w5</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w6</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o1</span>

  <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">all_y_trues</span><span class="p">):</span>
    <span class="s1">'''
</span><span class="s1">    - data is a (n x 2) numpy array, n = # of samples in the dataset.
</span><span class="s1">    - all_y_trues is a numpy array with n elements.
</span><span class="s1">      Elements in all_y_trues correspond to those in data.
</span><span class="s1">    '''</span>
    <span class="n">learn_rate</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">epochs</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1"># number of times to loop through the entire dataset</span>

    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_true</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">all_y_trues</span><span class="p">):</span>
        <span class="c1"># --- Do a feedforward (we'll need these values later)</span>
        <span class="n">sum_h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">sum_h1</span><span class="p">)</span>

        <span class="n">sum_h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w3</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">sum_h2</span><span class="p">)</span>

        <span class="n">sum_o1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w5</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w6</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span>
        <span class="n">o1</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">o1</span>

        <span class="c1"># --- Calculate partial derivatives.</span>
        <span class="c1"># --- Naming: d_L_d_w1 represents "partial L / partial w1"</span>
        <span class="n">d_L_d_ypred</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span>

        <span class="c1"># Neuron o1</span>
        <span class="n">d_ypred_d_w5</span> <span class="o">=</span> <span class="n">h1</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>
        <span class="n">d_ypred_d_w6</span> <span class="o">=</span> <span class="n">h2</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>
        <span class="n">d_ypred_d_b3</span> <span class="o">=</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>

        <span class="n">d_ypred_d_h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w5</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>
        <span class="n">d_ypred_d_h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w6</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_o1</span><span class="p">)</span>

        <span class="c1"># Neuron h1</span>
        <span class="n">d_h1_d_w1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h1</span><span class="p">)</span>
        <span class="n">d_h1_d_w2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h1</span><span class="p">)</span>
        <span class="n">d_h1_d_b1</span> <span class="o">=</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h1</span><span class="p">)</span>

        <span class="c1"># Neuron h2</span>
        <span class="n">d_h2_d_w3</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h2</span><span class="p">)</span>
        <span class="n">d_h2_d_w4</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h2</span><span class="p">)</span>
        <span class="n">d_h2_d_b2</span> <span class="o">=</span> <span class="n">deriv_sigmoid</span><span class="p">(</span><span class="n">sum_h2</span><span class="p">)</span>

        <span class="c1"># --- Update weights and biases</span>
        <span class="c1"># Neuron h1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h1</span> <span class="o">*</span> <span class="n">d_h1_d_w1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h1</span> <span class="o">*</span> <span class="n">d_h1_d_w2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b1</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h1</span> <span class="o">*</span> <span class="n">d_h1_d_b1</span>

        <span class="c1"># Neuron h2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w3</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h2</span> <span class="o">*</span> <span class="n">d_h2_d_w3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h2</span> <span class="o">*</span> <span class="n">d_h2_d_w4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b2</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_h2</span> <span class="o">*</span> <span class="n">d_h2_d_b2</span>

        <span class="c1"># Neuron o1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w5</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_w5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w6</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_w6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b3</span> <span class="o">-=</span> <span class="n">learn_rate</span> <span class="o">*</span> <span class="n">d_L_d_ypred</span> <span class="o">*</span> <span class="n">d_ypred_d_b3</span>

      <span class="c1"># --- Calculate total loss at the end of each epoch</span>
      <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feedforward</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">mse_loss</span><span class="p">(</span><span class="n">all_y_trues</span><span class="p">,</span> <span class="n">y_preds</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"Epoch </span><span class="si">%d</span><span class="s2"> loss: </span><span class="si">%.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss</span><span class="p">))</span>

<span class="c1"># Define dataset</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># Alice</span>
  <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>   <span class="c1"># Bob</span>
  <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>   <span class="c1"># Charlie</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">],</span> <span class="c1"># Diana</span>
<span class="p">])</span>
<span class="n">all_y_trues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
  <span class="mi">1</span><span class="p">,</span> <span class="c1"># Alice</span>
  <span class="mi">0</span><span class="p">,</span> <span class="c1"># Bob</span>
  <span class="mi">0</span><span class="p">,</span> <span class="c1"># Charlie</span>
  <span class="mi">1</span><span class="p">,</span> <span class="c1"># Diana</span>
<span class="p">])</span>

<span class="c1"># Train our neural network!</span>
<span class="n">network</span> <span class="o">=</span> <span class="n">OurNeuralNetwork</span><span class="p">()</span>
<span class="n">network</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">all_y_trues</span><span class="p">)</span></code></pre>
 </div>
 <p data-pid="N4sTkzIM">随着学习过程的进行，损失函数逐渐减小。<br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-a0435513c747f70eb38929117ab0cf47_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="507" data-rawheight="387" data-original-token="v2-a0435513c747f70eb38929117ab0cf47" class="origin_image zh-lightbox-thumb" width="507" data-original="https://pica.zhimg.com/v2-a0435513c747f70eb38929117ab0cf47_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="oPatnpBb">现在我们可以用它来推测出每个人的性别了：</p>
 <div class="highlight">
  <pre><code class="language-python"><span class="c1"># Make some predictions</span>
<span class="n">emily</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 128 pounds, 63 inches</span>
<span class="n">frank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># 155 pounds, 68 inches</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"Emily: </span><span class="si">%.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">network</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">emily</span><span class="p">))</span> <span class="c1"># 0.951 - F</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"Frank: </span><span class="si">%.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">network</span><span class="o">.</span><span class="n">feedforward</span><span class="p">(</span><span class="n">frank</span><span class="p">))</span> <span class="c1"># 0.039 - M</span></code></pre>
 </div>
 <h2><b>更多</b><br></h2>
 <p data-pid="K1yyu1t9">这篇教程只是万里长征第一步，后面还有很多知识需要学习：</p>
 <p data-pid="1s9Vlz4A">1、用更大更好的机器学习库搭建神经网络，如Tensorflow、Keras、PyTorch<br>
  2、在浏览器中的直观理解神经网络：<a href="https://link.zhihu.com/?target=https%3A//playground.tensorflow.org/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">playground.tensorflow.org</span><span class="invisible">/</span><span class="ellipsis"></span></a><br>
  3、学习sigmoid以外的其他激活函数：<a href="https://link.zhihu.com/?target=https%3A//keras.io/activations/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">keras.io/activations/</span><span class="invisible"></span></a><br>
  4、学习SGD以外的其他优化器：<a href="https://link.zhihu.com/?target=https%3A//keras.io/optimizers/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">keras.io/optimizers/</span><span class="invisible"></span></a><br>
  5、学习卷积神经网络（CNN）<br>
  6、学习递归神经网络（RNN）</p>
 <p data-pid="TwuiWzUB">这些都是Victor给自己挖的“坑”。他表示自己未来“可能”会写这些主题内容，希望他能陆续把这些坑填完。如果你想入门神经网络，不妨去订阅他的博客。</p>
 <h2><b>关于这位小哥</b></h2>
 <p data-pid="HOI8hvpw">Victor Zhou是普林斯顿2019级CS毕业生，已经拿到Facebook软件工程师的offer，今年8月入职。他曾经做过JS编译器，还做过两款页游，一个仇恨攻击言论的识别库。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-15dcba5bdf7b3fbabe1801673bdf8b34_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="150" data-rawheight="150" data-original-token="v2-15dcba5bdf7b3fbabe1801673bdf8b34" class="content_image" width="150">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="b05Sm1bf">最后附上小哥的博客链接：<br></p><a href="https://link.zhihu.com/?target=https%3A//victorzhou.com/" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">victorzhou.com/</span><span class="invisible"></span></a>
 <p data-pid="KlnHLQSs">— <b>完</b> —</p>
 <p data-pid="GVBOkcbA">量子位 · QbitAI<br>
  վ'ᴗ' ի 追踪AI技术和产品新动态</p><a href="https://www.zhihu.com/org/liang-zi-wei-48" data-draft-node="block" data-draft-type="link-card" data-image="https://pic4.zhimg.com/v2-ca6e7ffc10a0d10edbae635cee82d007_ipico.jpg" data-image-width="250" data-image-height="250" class="internal">量子位</a>
 <p data-pid="m4bqSTK5">欢迎大家关注我们，以及订阅<a href="https://zhuanlan.zhihu.com/qbitai" class="internal">我们的知乎专栏</a></p>
</body>