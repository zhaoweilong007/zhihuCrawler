# 据说大型芯片有几十亿个晶体管，一个都容不得出错，但为何芯片可靠性还这么高？
- 点赞数：13321
- 更新时间：2018年12月16日11时42分40秒
- 回答url：https://www.zhihu.com/question/303543828/answer/545971889
<body>
 <p data-pid="GC-R7wXs">我怎么发现截至12月5日我发帖前，几乎所有答案都机智的绕开了问题核心，抓住最粗浅最不足以说明原因的东西一通振振有词呢？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="VpY1n4-Q">先来剖析问题。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="lLMxmd2r">我看到的问题是“据说大型芯片有几十亿个晶体管，一个都容不得出错，但为何芯片可靠性还这么高？”。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Z1Zxk6se">这个问题问的很好，但不够专业。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="rITwbjwe">专业的问法可能是：</p>
 <p data-pid="INsO_JPJ">1、大型芯片（如CPU）有几十亿个晶体管，如果晶体管有制作缺陷，芯片当然就会执行出错。请问如何保证它们不被做坏？</p>
 <p data-pid="VXLYqP4T">2、大型芯片（如CPU）有几十亿个晶体管，而且每秒可以执行几十亿条指令；发生任何错误都可能影响程序的正确性。请问为何它可以抵抗诸如电压波动等诸多环境干扰，实现7X24小时的可靠性（7X24小时指的是一周七天，每天24小时，一秒休息都没有的连续服务）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ucZOu98K">对这两个问题，各有不同的答案。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gpmBKDub">对问题一，问的是硬件生产的可靠性。</p>
 <p data-pid="1wQO8DPQ">这个可靠性依靠的是很多很多方面的协同努力。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="TP7CagDW">首先，我们需要提纯硅。硅片越纯，杂质的干扰就越小。</p>
 <p data-pid="nnHUbXFu">一般的半导体器件，比如你家老式收音机里用的三极管之类，就要求99.9999%以上的高纯硅（6个9）；而大规模集成电路需要至少99.9999999%以上的高纯硅（9个9）；如CPU这样的计算机芯片，则需要99.999999999%以上的高纯硅（11个9）；人类目前能制造的最纯的硅材料，纯度可达12个9。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Xv-DK4aC">换句话说，硅片本身就有极高的纯度，以致于用于CPU生产的一千亿个硅原子中，只允许含有最多一个其它原子。</p>
 <p data-pid="WEECiOe9">——千亿绿豆中只有一颗红豆太夸张？万一五颗红豆好死不死恰好一起出现在10厘米范围内呢？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="n4XMRw_1">仅仅纯度高还不够。用来做芯片的硅，它还必须“生长”为“单晶硅”——也就是说，硅原子的晶格排布必须整齐划一，像多晶硅那样杂乱无章是不行的。</p>
 <p data-pid="5ZGjH2Xx">如果你问“如此高纯度的硅是如何提纯的？”，那么我只能回答“这是生产厂家的技术秘密，全世界都没多少人知道”。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ZPOgLFKh">单晶硅里面，杂质分布并不均匀。杂质富集区很容易导致（意料之外的）漏电流增大、晶格缺陷等诸多问题（现代芯片制造甚至会借助各向异性刻蚀等手段，晶格缺陷必然导致刻蚀出的沟道畸形），这些都可能加大芯片的失败率、增加它的发热量、限制它的性能。</p>
 <p data-pid="8wycz1s4"><a href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/269bc002cdbff121dd36a32d7375a417866fc132.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">【图文】第10章 干法刻蚀_百度文库</a></p>
 <p data-pid="LxUJgvf5">因此，普通的晶体管，6个9的硅便可满足需求；大规模集成电路就必须9个9；CPU这样的超大规模集成电路，11个9的高纯硅才可能把良品率提高到可行范围——芯片行业可不缺聪明人，10个9够用他们就绝不会像个冤大头一样，掏大价钱买11个9的昂贵材料。毕竟纯度加一个9可不是多敲一下键盘那么简单：你猜人类已经能造12个9的硅材料了为什么不大量应用呢？</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="oCWaAyhr">有了最好的原料，才有可能做出最高品质的成品——让你在沾了油的宣纸上写字，这副作品是不是就很难完美了？一样的道理。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="VP6Cv5lG">把我的一段评论贴上来：</p>
 <blockquote data-pid="-LdzsCHX">
  现在集成电路的线宽只有几十个纳米（甚至十几个纳米）。
  <br>
  <br>
  掺杂的目的，是在这几十个纳米的范围内、该磷是磷该硼是硼、准确的把它注入纯净的硅晶格之间，从而在局部生成P型和N型半导体，使得它们恰好组成电气性能合格的场效应管（构成的门电路）。
  <br>
  <br>
  说场效应管有点粗糙了。实质上，因为半导体原理以及电路原理，芯片上几十个纳米宽度的P区和N区交错纵横，它们彼此之间还能形成许多寄生电路——而CMOS工艺甚至能利用这些寄生电路为我们服务。
  <br>
  <br>
  把如此精确的、定点生成P/N型半导体的工艺叫“掺杂”，是因为半导体材料方面的研究以硅锗为主——或者说，半导体就是往硅/锗里掺入不同物质、然后研究它们的导电性的一门学科。
  <br>
  <br>
  为了便于讨论，当我们谈起半导体时，如果总是说“往硅中掺入五价元素A”“掺入三价元素B”实在太麻烦了。尤其是不关心或者不知道究竟掺了什么时，这样就更啰嗦了。
  <br>
  <br>
  半导体主要就是利用它的电气特性，因此绝大多数场合都不关心掺了什么只关心电气特性。
  <br>
  <br>
  因此，在不需要讨论具体工艺参数时，业内就笼统的说“掺入杂质”或者“掺杂”。
  <br>
  <br>
   习惯这么说之后，集成电路工艺里，准确的在硅片某个区域的晶格间注入某种五价元素/三价元素这一步，就也被简称为“掺杂”。
  <br>
  <br>
  因此，再强调一遍：<b>千万不要望文生义，以为纯净的硅不好用，做集成电路前还得添点杂质进去</b>。
  <br>
  <br>
  事实上，<b>这一步工艺虽然叫“掺杂”，但实际上是在硅片上就地制作晶体管</b>！
  <br>
  注意PN结两侧掺的东西可是不一样的，容不得半点混淆！每种元素的掺入位置也必须绝对精确，不然将来只有几十甚至十几个纳米的线路搭不上，这芯片可就做废了。
  <br>
  <br><b>敢把这个真当成“随随便便撒点杂质”那种“掺杂”，那可丢人丢大发了</b>。
 </blockquote>
 <p data-pid="Md-DtAr-"><a href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/798d30a08762caaedd33d429.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">【图文】CMOS集成电路制造工艺介绍_百度文库</a></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ImDX-Cu5">和对硅片的苛刻要求一样，光刻机本身，从透镜的磨制精度到光刻胶到切割出的晶圆的平整度再到用到的一切一切，几十项工艺以及这些工艺需要用到的工具/材料，几乎全都有很高级别的苛刻要求（注意这几十项仅仅是工艺，真正要做的事项可不止这么一点点）。</p>
 <p data-pid="YLVM0y7j">任何方面微乎其微的、拿最好的光学显微镜都看不清的一丁点缺陷，都可能导致芯片良品率直线下降——甚至，哪怕一切到位，哪怕Intel这种业界顶尖公司，新工艺上马，良品率往往也相当的低。经常需要长时间的调试、磨合，才能保证良品率达到可用范围。</p>
 <p data-pid="th459Ffd"><a href="https://www.zhihu.com/question/54061323" class="internal">是什么问题导致 10 纳米制程芯片良品率过低？会对下游产品有何影响？</a></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Gd5j23NY">不仅光刻机本身。它所处的环境也都要求苛刻。</p>
 <p data-pid="x1UHCcOq">比如，它必须置于严格无尘的环境里。因为落到芯片上的一粒灰尘，就可能毁掉数百个门电路。</p>
 <p data-pid="16J9pwtc"><a href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/13c777aebd64783e09122be9.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">wenku.baidu.com/view/13</span><span class="invisible">c777aebd64783e09122be9.html</span><span class="ellipsis"></span></a></p>
 <p data-pid="D0S7BilQ">请注意，这是一个很老的规范了，可能无法满足现代光刻机的需要。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="luP-t8Pl">类似的，如果不采取严格避震措施，光刻机工作时，800米外一辆汽车开过，引起的颤动都可能导致大批芯片报废！</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="1VdYNz5j">总之，通过数不清的方面无数科研人员、工程师以及技术工人的各种努力，弥补一切方面的一切短板，该妥协的地方酌情妥协，人类终于可以保证，CPU芯片上光刻出的门电路，出错概率可低于亿分之几（老黄历了，现在能达到多少我还不清楚）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="NsMXBCWM">对于普通级别的芯片，这个工艺水平已经可以保证“出错几乎是不可能的”——因此颇有一些人以为“做芯片什么都不用管坏了就扔就行”。但他们并不知道，别人为了把芯片产线质量稳定度提高到这个程度付出了多少辛劳。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="i3gpxIyc">但对CPU这样最为尖端的、同时挑战集成度和可靠性的芯片，这样往往也还不够。</p>
 <p data-pid="OpZ60Jic">因此，人类在设计CPU电路时，便将其模块化；然后故意制造出冗余的重复模块来；当CPU光刻完成后，通过测试，屏蔽掉不良模块（不良模块不仅仅是出错的模块，还包括热稳定性不佳等缺陷）。这样哪怕发生了少量错误，制作成功的几率也不会太低。</p><a href="https://www.zhihu.com/question/23919992" data-draft-node="block" data-draft-type="link-card" class="internal">Intel i3 和 i7 的成本差是多少？如果成本相当，为什么不全生产 i7 呢？</a>
 <p data-pid="3jIWsqrj">更进一步的，如果不良模块实在太多、以至于整个核心都不能用了，还可以屏蔽掉整个核心——原始设计是8核，屏蔽4个就可以当4核卖了。六核双核等情况依此类推。</p>
 <p data-pid="jHGn393N">（当然，有时候运气好良品率特高，但舍不得掏钱的用户对低端CPU有需求，高端的生产太多又卖不掉，厂商也可能故意把高端CPU的核心屏蔽掉、频率限低，当低端CPU卖给用户——这和主题无关，就不讨论了）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="GP935UXA">但是，请注意，<b>这个冗余设计既浪费芯片面积，又加大了研发投入、增加了诸多方面的复杂性</b>，<b>只有类似CPU这样挑战人类极限的工程，迫不得已才会采用</b>——所以才说，拿“坏了就屏蔽/坏了就扔”当真相的都欠缺常识。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="O4GgGZwp">打个比方的话，问“我要经常开车跑长途，这可能做到吗？”</p>
 <p data-pid="7tU2u2VA">正确回答是，先挑选质量足够高的车，汽车工业刚起步时几十公里就得修一次的烂车是没法用的（提高原料质量工艺可靠性）；然后选用更容易排错维修的车型（设计时考虑可维修性）；最后，真跑废了就扔掉再买一辆。</p>
 <p data-pid="Z2RetEid">嗯，跑长途基本靠扔车？你觉得这回答过脑子了吗？真拿扔车不当回事的那叫F1，不是长途司机。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="OGuayqFJ">——那些张嘴就拿屏蔽说事的，多半是懒得动脑。他们就没想过，如果拿6个9的硅片造CPU，这密密麻麻的缺陷，靠屏蔽能屏蔽过来吗？更不用说随便抓把石英砂拿电炉土法上马搞的浑浊不堪的垃圾硅了。</p>
 <p data-pid="4heJJ3Sx"><b>必须先有一个极高稳定度的平台，才有耍屏蔽之类小聪明的余地</b>。</p>
 <p data-pid="lhLnFDAa">——换句话说，屏蔽是很有效，但它在这个问题里，是最不重要最没技术含量的因素。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="4OhOhnc7">PS：鉴于某些假装专家的外行捣乱，我在这里科普下所谓的“屏蔽”究竟是怎么一回事。</p>
 <p data-pid="5UvYZurz">我们知道，内存有很多很多单元，但总线只有一条。那么，当CPU要访问64g内存中的其中一个单元时，它就要在地址线上输出一组电平，使得该内存单元被选中（实际相当于通过一组与门，切断了除被选择单元外其它任何内存单元的输出信号），然后就可以读到正确的值了。</p>
 <p data-pid="Bb5ZnBK2">实际上，计算机里的一切，上至寄存器下至键盘，都是以同样的逻辑控制输入输出的。只不过未必都在总线上（或者说没有统一编址）而已。</p>
 <p data-pid="RiOcVWsT">CPU内部也是如此。核心之间有通信线路，核心内部，从加法器到寄存器再到缓存，全都有类似总线的数据―地址线路相互连接。</p>
 <p data-pid="_QRCnDPP">因此，只需记录错误单元的地址，避免访问它甚至不给它供电，就可以达到屏蔽的目的了（反过来也行：比如记录寄存器EAX等和内部地址的对应表，不注册坏掉的寄存器或其它单元，也可达到屏蔽的目的）。</p>
 <p data-pid="vEOhEWiz">这种屏蔽甚至可以是自动的：通过检测，给坏掉的单元置位；然后在CPU自检流程排除它们即可。</p>
 <p data-pid="9NJ_AMWM">总之，可行的做法很多很多，具体某个厂商用了哪种是不可预测的。我们只需知道“能做到”就对了。</p>
 <p data-pid="qo8lA693">假专家只知道硬连线、跳线，说明他还是有点电路基础的。但他显然不懂数字电路的地址机制，不知道就连寄存器都是有地址的（但注意和内存地址区分。它是CPU核心内部地址，这个地址甚至对同一颗CPU的另一个核心都可能是不可见的）；有地址，只要不是短路型故障（短路故障还需要从供电上屏蔽），就可以用简单的“避免访问”达到“屏蔽”目的。换句话说就是：这人计算机原理学的一塌糊涂，数字电路基本还是没入门水平。大二相关科目也不知怎么混过去的。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="68V7Je8s">当然，我拿寄存器举例是为了说明问题，证明哪怕寄存器这种粒度都有办法屏蔽，并不代表CPU就真的细致到了寄存器这个粒度。实际上，有工艺精度保证，粒度太小了反而增加成本，工程是需要根据实际情况取舍的。</p>
 <p data-pid="vn28czNL">——这段严格来说是废话，不用说大家都知道；但万一遇到手电筒专家一样只照别人不照自己的家伙……还是明确写出来省事。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="EA8-19Sd">对问题二，这个要通过软硬件配合来解决。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="UD6c6igs">首先，成熟的硬件本身就非常非常的稳定，可以长时间运行不发生任何错误（但很多情况下，错误在所难免。比如电磁干扰、机械振动、宇宙射线等等）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="ojHpZ9Qs">其次，计算机硬件本身也可以自带校验功能。比如服务器经常用带ECC校验的内存条。</p>
 <p data-pid="PGJ5yof_">当硬件出错时，它可以自动发现，然后通过中断通知软件处理（或自动尝试恢复）。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="rALiOvZd">然后，程序员在写程序时，也会有很多错误检查；一旦校验出错，程序便立即退出。</p>
 <p data-pid="JwCU52ej">为了保证7X24小时安全性，业界有许多成熟的经验甚至现成的框架。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="v10przOq">比如，有一种硬件叫“看门狗(watchdog)”，它相当于一个自动递减的计数器；如果软件运行正常，那么它就应该不停复位这个计数器，避免它递减到零；如果计数器递减到零，就说明软件运行出错了；于是芯片立即重启、然后软件尝试恢复执行——单片机系统经常用到它。</p>
 <p data-pid="6UIoeJ3H">当恢复时间足够短时，人就不会觉察到系统曾经失败过（但一般会记入日志，以便分析故障原因）；对很多系统，包括汽车/飞机/卫星上的各种系统，只要恢复时间足够短（依设计允许的余量而定），也不会影响它们正常运行。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="KprGSvFw">PC/服务器一般不用简陋的看门狗，它们有完善得多的错误发现/恢复机制。包括但不限于权限检查、错误中断以及编程语言提供的结构化异常等等机制。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="CkY5d7Iw">出错了的程序会立即退出？你可能会说，不对啊，这样服务不就中断了吗？</p>
 <p data-pid="KeGLZgn_">没关系。我们可以准备一个监控程序，定时检查，发现服务程序失败就重新拉起它。</p>
 <p data-pid="PruK5Oai">这个监控逻辑也可置于服务应用本身，然后同时运行两个同样的应用，让它们互为备份。这就是著名的“双进程相互监控、相互唤醒”——这个技术之所以如此著名，是因为有人拿它不办正事，而是拿来做流氓软件坑用户了。嗯，好的技术落到坏人手里就是这种下场。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gs8F2JhP">对各种网站/搜索引擎之类庞然大物，依靠单台服务器的自我恢复能力已经不够。这时候还可以通过双机热备份/多机热备份（多台机器执行同样的程序，只是其它机器只运行但不输出结果；当其中一台出错时，另一台便可立即顶替它）、集群计算（如Google通过map-reduce灵活组合使用数万甚至更多台计算机，可自动分配任务、自动发现故障节点并屏蔽它）等等更为复杂、高级的架构，使得偶发故障不会影响它们的服务能力。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="bogjCJr0">更进一步的，针对天灾、战争甚至核战争等等罕见事件，人们还开发了“异地容灾系统”，使得哪怕城市A的服务节点因重大事故无法服务，远隔千里的城市B的服务节点也可立即接替它，从而达到“不可摧毁”的目的。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="RhMpYt_X"><b>化不可能为现实，这就是人类的智慧</b>。</p>
 <p></p>
</body>