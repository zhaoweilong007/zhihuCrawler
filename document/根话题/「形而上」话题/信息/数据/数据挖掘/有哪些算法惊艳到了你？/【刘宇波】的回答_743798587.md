# 有哪些算法惊艳到了你？
- 点赞数：16431
- 更新时间：2020年06月23日16时39分59秒
- 回答url：https://www.zhihu.com/question/26934313/answer/743798587
<body>
 <p data-pid="jfjuquBH">写一个看似很简单的算法，但第一次理解清楚他的原理以后，真的惊艳到了我：）</p>
 <p data-pid="z8Z-Iz61">这篇文章首发在我的公众号【<b>是不是很酷</b>】：<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4NTIxODYwMQ%3D%3D%26mid%3D2247484310%26idx%3D1%26sn%3D916f92afff6016256648cfb3c7fd83e7%26chksm%3Dfd8cacd0cafb25c670587f22524b111d74b4ddd9954070930b6ef6efb1bd8fba13d4250e57d8%26token%3D885428195%26lang%3Dzh_CN%23rd" class=" wrap external" target="_blank" rel="nofollow noreferrer">神一样的随机算法</a>。公众号ID：<b>isnt_<i>it_</i>cool </b></p>
 <p data-pid="3-_pM-Mw">欢迎大家关注，和我一起，用技术的眼光看世界：）</p>
 <hr>
 <p data-pid="qJ79SSJ0">这篇文章，我们从一道经典面试题开始来探讨这个问题。这个面试题有很多形式，但其实背后的算法是一致的。</p>
 <p data-pid="VSMbD0EY">这个问题是：<b>设计一个公平的洗牌算法</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="BIbkkz2f"><b>1.</b></p>
 <p data-pid="B6Vi_H8L">看问题，洗牌，显然是一个随机算法了。随机算法还不简单？随机呗。把所有牌放到一个数组中，每次取两张牌交换位置，随机 k 次即可。</p>
 <p data-pid="tATXLTyV">如果你的答案是这样，通常面试官会进一步问一下，k 应该取多少？100？1000？10000？</p>
 <p data-pid="rxfz5Dgv">很显然，取一个固定的值不合理。如果数组中有 1000000 个元素，随机 100 次太少；如果数组中只有 10 个元素，随机 10000 次又太多。一个合理的选择是，随机次数和数组中元素大小相关。比如数组有多少个元素，我们就随机多少次。</p>
 <p data-pid="OwNor7HN">这个答案已经好很多了。但其实，连这个问题的本质都没有触及到。此时，面试官一定会狡黠地一笑：这个算法公平吗？</p>
 <p data-pid="KzcC_cNh">我们再看问题：设计一个 <b>公平</b> 的洗牌算法。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="FkmzT_7s"><b>2.</b></p>
 <p data-pid="gfVbd4rc">问题来了，对于一个洗牌算法来说，什么叫“公平”？这其实是这个问题的实质，我们必须定义清楚：什么叫公平。</p>
 <p data-pid="2hhXib4d">一旦你开始思考这个问题，才触及到了这个问题的核心。<b>在我看来，不管你能不能最终给出正确的算法，如果你的思路是在思考对于洗牌算法来说，什么是“公平”，我都觉得很优秀。</b></p>
 <p data-pid="Zi1ApHq_">因为背出一个算法是简单的，但是这种探求问题本源的思考角度，绝不是一日之功。别人告诉你再多次“要定义清楚问题的实质”都没用。这是一种不断面对问题，不断解决问题，逐渐磨炼出来的能力，短时间内无法培训。</p>
 <p data-pid="2WTl9wdZ">这也是我经常说的，<b>面试不是标准化考试，不一定要求你给出正确答案。面试的关键，是看每个人思考问题的能力。</b></p>
 <p data-pid="rxV7pgni">说回我们的洗牌算法，什么叫公平呢？一旦你开始思考这个问题，其实答案不难想到。洗牌的结果是所有元素的一个排列。一副牌如果有 n 个元素，最终排列的可能性一共有 n! 个。公平的洗牌算法，应该能<b>等概率地给出这 n! 个结果中的任意一个。</b></p>
 <p data-pid="JYT8QobW">如思考虑到这一点，我们就能设计出一个简单的暴力算法了：对于 n 个元素，生成所有的 n! 个排列，然后，随机抽一个。</p>
 <p data-pid="s7LS8ahq">这个算法绝对是公平的。但问题是，复杂度太高。复杂度是多少呢？O(n!)。因为，n 个元素一共有 n! 种排列，我们求出所有 n! 种排列，至少需要 n! 的时间。</p>
 <p data-pid="1UUwoOag">有一些同学可能对 O(n!) 没有概念。我本科时就闹过笑话，正儿八经地表示 O(n!) 并不是什么大不了不起的复杂度。实际上，这是一个比指数级 O(2^n) 更高的复杂度。因为 2^n 是 n 个 2 相乘；而 n! 也是 n 个数字相乘，但除了 1，其他所有数字都是大于等于 2 的。当 n&gt;=4 开始，n! 以极快的的速度超越 2^n。</p>
 <p data-pid="3GsfkcxG">O(2^n) 已经被称为指数爆炸了。O(n!) 不可想象。</p>
 <p data-pid="FMQMaA10">所以，这个算法确实是公平的，但是，时间不可容忍。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="s0TmWi96"><b>3.</b></p>
 <p data-pid="bJAsg9Xl">我们再换一个角度思考“公平”这个话题。其实，我们也可以认为，公平是指，<b>对于生成的排列，每一个元素都能独立等概率地出现在每一个位置。</b>或者反过来，<b>每一个位置都能独立等概率地放置每个元素。</b></p>
 <p data-pid="Fc5pXTfp">基于这个定义，我们就可以给出一个简单的算法了。说这个算法简单，是因为他的逻辑太容易了，就一个循环：</p>
 <div class="highlight">
  <pre><code class="language-cpp"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">--</span> <span class="p">)</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">rand</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)])</span> <span class="c1">// rand(0, i) 生成 [0, i] 之间的随机整数
</span></code></pre>
 </div>
 <p data-pid="aMq5sPMv">这么简单的一个算法，可以保证上面我所说的，对于生成的排列，<b>每一个元素都能独立等概率的出现在每一个位置。</b>或者反过来，<b>每一个位置都能独立等概率的放置每个元素。</b></p>
 <p data-pid="qsvAQnHE">大家可以先简单的理解一下这个循环在做什么。其实非常简单，i 从后向前，每次随机一个 [0...i] 之间的下标，然后将 arr[i] 和这个随机的下标元素，也就是 arr[rand(0， i)] 交换位置。</p>
 <p data-pid="cCm31Irt">大家注意，由于每次是随机一个 [0...i] 之间的下标，所以，在每一轮，是可以自己和自己交换的。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="bbgUyXqv">这个算法就是大名鼎鼎的 <b>Knuth-Shuffle，即 Knuth 洗牌算法。</b></p>
 <p data-pid="DnJBAO6X">这个算法的原理，我们稍后再讲。先来看看 Knuth 何许人也？</p>
 <p data-pid="6KemM-pB">中文名：高纳德。算法理论的创始人。我们现在所使用的各种算法复杂度分析的符号，就是他发明的。上世纪 60-70 年代计算机算法的黄金时期，近乎就是他一手主导的。他的成就实在太多，有时间单独发文介绍，但是，我觉得一篇文章是不够的，一本书还差不多。</p>
 <p data-pid="sMWvgNYT">大家最津津乐道的，就是他所写的《The Art of Computer Programming》，简称 TAOCP。这套书准备写七卷本，然后，到今天还没有写完，但已经被《科学美国人》评为可以媲美相对论的巨著。</p>
 <p data-pid="_tNCtwlt">微软是 IT 界老大的年代，比尔盖茨直接说，如果你看完了这套书的第一卷本，请直接给我发简历。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-cdd7e48c2dc84e7083429342ba8963c7_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="309" data-original-token="v2-1f25c981c0fb7fa2a14785cbb9c224df" data-default-watermark-src="https://pic1.zhimg.com/50/v2-8ad137ab295839cd0aed96576dad75b9_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-cdd7e48c2dc84e7083429342ba8963c7_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="_xEu8CTP">至于这套书为什么写的这么慢？因为老爷子写到一半，觉得当下的文字排版工具都太烂，于是<b>转而发明出了现在Tex文字排版系统，这就是现在大名鼎鼎的 LaTeX 的雏形...</b></p>
 <p data-pid="GA7t8Bom">另外，老爷子可能觉得当下的编程语言都不能完美地表现自己的逻辑思想，还<b>发明了一套抽象的逻辑语言，用于这套书中的逻辑表示...</b></p>
 <p data-pid="v4A0Y8HT">下面这张照片是他年轻的时候。这张照片是我在斯坦福大学计算机学院的橱窗拍的。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-c51941aa063b57e8e6f8d4a16d4e2230_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="1200" data-original-token="v2-0839b1881abd677372fbd1df073d62da" data-default-watermark-src="https://pic1.zhimg.com/50/v2-522ec664ea88ed1381188644703a4943_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-c51941aa063b57e8e6f8d4a16d4e2230_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="eFHczoC_">下面的话和大家共勉：</p>
 <blockquote data-pid="N5xGL7WN">
  A programmer who subconsciously views himself as an artist will enjoy what he does and will do it better.
  <br>
  <br>
  Donald E. Knuth 1978
 </blockquote>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="0ykj8VkC">所以，我从来都不认为自己只是一名工程师而已。<b>我是艺术家：）</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="P-hK8w_S"><b>4.</b></p>
 <p data-pid="4AUTywtF">是时候仔细的看一下，这个简单的算法，为什么能做到保证：<b>对于生成的排列，每一个元素都能等概率的出现在每一个位置</b>了。</p>
 <p data-pid="7N6_elY_">其实，简单的吓人：）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="7MU74V4Q">在这里，我们模拟一下算法的执行过程，同时，对于每一步，计算一下概率值。</p>
 <p data-pid="xTFAwFa3">我们简单的只是用 5 个数字进行模拟。假设初始的时候，是按照 1，2，3，4，5 进行排列的。</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-4eb87a5d3766ebbcd709084c01eaae1c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="273" data-original-token="v2-5cdcf1c57fef5094a19d92f990ff95fa" data-default-watermark-src="https://pic1.zhimg.com/50/v2-7d91c5d253425514e1496814f397dcac_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pic1.zhimg.com/v2-4eb87a5d3766ebbcd709084c01eaae1c_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="AbyBrx_j">那么，根据这个算法，首先会在这五个元素中选一个元素，和最后一个元素 5 交换位置。假设随机出了 2。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-5aa51399457a559d774c68b8fd63e008_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="351" data-original-token="v2-f3ad04d9ded632ba034591a26ed36879" data-default-watermark-src="https://pic1.zhimg.com/50/v2-c4feae646d6a65ce64e359f3ce1edd2f_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pic1.zhimg.com/v2-5aa51399457a559d774c68b8fd63e008_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="T4uIcOoJ">下面，我们计算 2 出现在最后一个位置的概率是多少？非常简单，因为是从 5 个元素中选的嘛，就是 1/5。实际上，根据这一步，任意一个元素出现在最后一个位置的概率，都是 1/5。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-3c7a2b6282971cb88d92ffd9f6de0881_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="342" data-original-token="v2-ba595b42f999c8cc0ac07bbac2451e73" data-default-watermark-src="https://pica.zhimg.com/50/v2-9282f27925c3f0525a084aca08ecd7e5_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pica.zhimg.com/v2-3c7a2b6282971cb88d92ffd9f6de0881_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="j99Rz5uz">下面，根据这个算法，我们就已经不用管 2 了，而是在前面 4 个元素中，随机一个元素，放在倒数第二的位置。假设我们随机的是 3。3 和现在倒数第二个位置的元素 4 交换位置。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-8919cbcae35631a28f3dd99cc86ece0d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="332" data-original-token="v2-df3325df62805a17322ec0a06899dd47" data-default-watermark-src="https://pic1.zhimg.com/50/v2-88d87245a362eb5a35e0ff704a61a66f_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-8919cbcae35631a28f3dd99cc86ece0d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="CPdJKJbw">下面的计算非常重要。3 出现在这个位置的概率是多少？计算方式是这样的：</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-fd127ad10a65ef26743db6f69a71f66d_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="436" data-original-token="v2-872cc8c2a08d3033262afcfe53d29baa" data-default-watermark-src="https://pic1.zhimg.com/50/v2-98061e9b9259e4f2da099194e6840401_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-fd127ad10a65ef26743db6f69a71f66d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="QLcxUdet">其实很简单，因为 3 逃出了第一轮的筛选，概率是 4/5，但是 3 没有逃过这一轮的选择。在这一轮，一共有4个元素，所以 3 被选中的概率是 1/4。因此，最终，3 出现在这个倒数第二的位置，概率是 4/5 * 1/4 = 1/5。</p>
 <p data-pid="XH9QBNO9">还是 1/5 !</p>
 <p data-pid="4ZTePwMz">实际上，用这个方法计算，任意一个元素出现在这个倒数第二位置的概率，都是 1/5。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Y3NT_oDp">相信聪明的同学已经了解了。我们再进行下一步，在剩下的三个元素中随机一个元素，放在中间的位置。假设我们随机的是 1。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-1099d6928228a54218a9c8ed5bef2a77_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="332" data-original-token="v2-d033c33fb4949a25e29f2f5339502362" data-default-watermark-src="https://picx.zhimg.com/50/v2-17d29e83c8f95e54fc58a8897fa41c07_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pica.zhimg.com/v2-1099d6928228a54218a9c8ed5bef2a77_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="IRukTP5-">关键是：1 出现在这个位置的概率是多少？计算方式是这样的：</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-8143c4e6413fcd940ca48e79a1003c85_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="449" data-original-token="v2-bb47e134db64b7990ecfda92e6beaeb9" data-default-watermark-src="https://pic1.zhimg.com/50/v2-8df7ef62af759344616b4769d542bca8_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pica.zhimg.com/v2-8143c4e6413fcd940ca48e79a1003c85_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="kvTvHCyn">即 1 首先在第一轮没被选中，概率是 4/5，在第二轮又没被选中，概率是 3/4 ，但是在第三轮被选中了，概率是 1/3。乘在一起，4/5 * 3/4 * 1/3 = 1/5。</p>
 <p data-pid="vcGRMbnX">用这个方法计算，任意一个元素出现在中间位置的概率，都是 1/5。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="kGRpc0dW">这个过程继续，现在，我们只剩下两个元素了，在剩下的两个元素中，随机选一个，比如是4。将4放到第二个位置。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-4a27417134d922cb253d24bcd50f376c_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="340" data-original-token="v2-97dc60145a3ef56bcfb79e1cf89f1c86" data-default-watermark-src="https://picx.zhimg.com/50/v2-f2c2398fff905b7484965f2b0c14b158_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-4a27417134d922cb253d24bcd50f376c_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="AVA0lsWS">然后，4 出现在这个位置的概率是多少？4 首先在第一轮没被选中，概率是 4/5；在第二轮又没被选中，概率是 3/4；第三轮还没选中，概率是 2/3，但是在第四轮被选中了，概率是 1/2。乘在一起，4/5 * 3/4 * 2/3 * 1/2 = 1/5。</p>
 <p data-pid="T79cJ0fk">用这个方法计算，任意一个元素出现在第二个位置的概率，都是 1/5。</p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-4206cc253c57d7aa90c139447f424489_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="465" data-original-token="v2-33d9d1ee219879093b9beccfc970b870" data-default-watermark-src="https://pic1.zhimg.com/50/v2-370b9854bc16395e00b059161e3d4298_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-4206cc253c57d7aa90c139447f424489_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="j_fYrILZ">最后，就剩下元素5了。它只能在第一个位置呆着了。</p>
 <p data-pid="gg174vVk">那么 5 留在第一个位置的概率是多少？即在前 4 轮，5 都没有选中的概率是多少？</p>
 <p data-pid="rukktiw3">在第一轮没被选中，概率是 4/5；在第二轮又没被选中，概率是 3/4；第三轮还没选中，概率是 2/3，在第四轮依然没有被选中，概率是 1/2。乘在一起，4/5 * 3/4 * 2/3 * 1/2 = 1/5。</p>
 <figure data-size="normal">
  <img src="https://pic1.zhimg.com/50/v2-6df4528e1d8a3c72577ead17ae6512f6_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="480" data-original-token="v2-08e92344eace07d41d3a1acc6d879e8c" data-default-watermark-src="https://pic1.zhimg.com/50/v2-95dfe39a05ff0606a2ba439346337eb1_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="900" data-original="https://picx.zhimg.com/v2-6df4528e1d8a3c72577ead17ae6512f6_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="jAethW0x">算法结束。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="LaHOK2LM">你看，在整个过程中，每一个元素出现在每一个位置的概率，都是 1/5 ！</p>
 <p data-pid="qmftUdbW">所以，这个算法是公平的。</p>
 <p data-pid="DnnHdmx5">当然了，上面只是举例子。这个证明可以很容易地拓展到数组元素个数为 n 的任意数组。整个算法的复杂度是 O(n) 的。</p>
 <p data-pid="Fg60lRf1">通过这个过程，大家也可以看到，同样的思路，我们也完全可以从前向后依次决定每个位置的数字是谁。不过从前向后，代码会复杂一些，感兴趣的同学可以想一想为什么？自己实现一下试试看？</p>
 <p data-pid="kcFdR57E">（因为生成 [0, i] 范围的随机数比生成 [i, n) 范围的随机数简单，直接对 i+1 求余就好了。）</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="wDuJkmo7">怎么样，<b>是不是很酷？</b></p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-ef21c682495d5d3ab11ec639e18fc4ff_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="2148" data-rawheight="1211" data-original-token="v2-dd867a5a88b0db10bebfa58c6b478629" data-default-watermark-src="https://picx.zhimg.com/50/v2-7de9107613d6788cfb2dee5357d9500d_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="2148" data-original="https://picx.zhimg.com/v2-ef21c682495d5d3ab11ec639e18fc4ff_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="oOgick3T"><b>5.</b></p>
 <p data-pid="7yec-1Wq">这个算法除了洗牌，还能怎么用？</p>
 <p data-pid="3ka434gO">其实，在很多随机的地方，都能使用。比如，扫雷生成随机的盘面。我们可以把扫雷的二维盘面先逐行连接，看作是一维的。之后，把 k 颗雷依次放在开始的位置。</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-92db1fe2d39a83932c342f8dbf0f5096_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1282" data-rawheight="1324" data-original-token="v2-8b052b246827276e6083d23ac16e8f53" data-default-watermark-src="https://picx.zhimg.com/50/v2-9b78e4df4d6cc7f9871e4acc363aefa8_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1282" data-original="https://picx.zhimg.com/v2-92db1fe2d39a83932c342f8dbf0f5096_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="2zAoUObv">然后，我们运行一遍 Knuth 洗牌算法，就搞定啦：</p>
 <figure data-size="normal">
  <img src="https://pica.zhimg.com/50/v2-204bff4780e3960249f8e704f9dc3c49_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="1328" data-original-token="v2-1548c890a967fa909ee8065f2f0b36dd" data-default-watermark-src="https://picx.zhimg.com/50/v2-1fb135e988e0d0047d4353da41d40314_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pica.zhimg.com/v2-204bff4780e3960249f8e704f9dc3c49_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="4C9Ob3X8"><b>是不是很酷？</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="41U9iFti">这就是我喜欢算法的原因。<b>在我眼里，算法从来不是枯燥的逻辑堆砌，而是神一样的逻辑创造。</b></p>
 <p data-pid="-NSkowmJ">尽管这个世界很复杂，但竟也如此的简洁，优雅。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="tRSBIWoz"><b>大家加油！：）</b></p>
 <hr>
 <p data-pid="BKI_NjEs">P.S.</p>
 <p data-pid="p3Dtsxpf">没想到获得这么多赞。先谢谢大家啦。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="mHBrfYGR">补充几点：</p>
 <p data-pid="Mg6pHd6a">1.</p>
 <p data-pid="KLrp93ea">首先，知乎大佬太多了。非常抱歉，我写的这么啰嗦，耽误一些大佬时间了。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="NH-Aqelr">2.</p>
 <p data-pid="QIz1metM">很多人说，rand()函数就不均匀，所以这个算法不均匀。没错。但这里，我谈的是Knuth-Shuffle的逻辑，而不是具体的实现。如果你的rand()不均匀，当然这个shuffle也不均匀。谈论这个问题的时候，我们假想rand()是无偏的。</p>
 <p data-pid="KxOHbzij">有些人很好心地在评论区提出了无偏的rand()实现思路，谢谢大家。把你认为无偏的rand()实现封装成代码里的rand()就好了。这个代码没有规定rand()的具体实现。rand()怎么实现也根本不是这篇文章的重点。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="mCOoSpHF">3.</p>
 <p data-pid="w5UgwymI">很多人说，把这些元素扔进一个口袋，然后每次不放回随机取出一个元素，生成排列，就好了。完全没问题！其实这个算法的本质也正是这么做的。只不过原地完成，空间复杂度O(1)。可以用这个思路再理解一遍这个算法。我的这个文章确实过于强调计算概率了，忽略了这个直观理解。感谢提醒。</p>
 <p data-pid="QQcZSKzY">但是，上面的这个“把这些元素扔进一个口袋，然后每次不放回随机取出一个元素，生成排列”过程，如果用代码实现，其实是复杂的，试试看？</p>
 <p data-pid="TU6YmDv_">而 Knuth Shuffle 这样一个思路，可以如此巧妙地原地完成上面的过程，恰恰是这个算法惊艳我的地方。它竟然如此简单。</p>
 <p data-pid="ZIY7iPPa">有意思的是，很多人说“这个问题哪里有这么复杂？”而整篇文章的关键就是：这个算法不复杂啊！只有两行。相反，大概率的，这些人想的思路，实现出来，其实是复杂的。最后优化来优化去，就会绕回到这个“简单“的算法上。（当然，如果是因为你水平太高，看我的文章写的啰嗦，请参考上面第1条。）</p>
 <p data-pid="EieDF7i8">我怀疑很多人根本不是计算机专业的，竟然思考不到单纯的“扔进一个口袋，然后每次不放回随机取出一个元素”这样的思路实现出来有什么坑。当然，不排除我才疏学浅，恳请各位大佬把那个“哪有这么复杂，比这个算法还简单”的代码摆出来。</p>
 <p data-pid="ULUlcQpW">Talk is cheap, show me the code.</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="k4Dxb0uJ">跳跃一下：</p>
 <p data-pid="r0DXZlGa">我突然觉得这是一个很好的面试题，下次面试用。</p>
 <p data-pid="Q7j6CNQ-">实现以下算法：一组数，每次不放回抽样，得到一个随机序列。白板编程。分析时间空间复杂度。</p>
 <p data-pid="X8VYFl9x">follow up：能否时间O(n)完成，能否空间O(1)完成。</p>
 <p data-pid="4U-ZREJQ">不考概率，不考随机算法，完全考工程实现。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="RvpxeiA9">4.</p>
 <p data-pid="zBiiFykl">原文说“每个元素能够等概率出现在每个位置”，确实不严谨，需要加入“独立”的条件，即“每个元素能够独立且等概率地出现在每个位置”。现已修改。感谢指正。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="QnKCEx6O">5.</p>
 <p data-pid="3Adeq8wj">文章中我说Knuth的英文名是高纳德，有误。应该是高德纳。为此我在公众号上发表了一篇新文章：<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4NTIxODYwMQ%3D%3D%26mid%3D2247484344%26idx%3D1%26sn%3Db534995fb6c5fca3cb49c400282cf7cc%26chksm%3Dfd8cacfecafb25e8d594c2b0530cc823a6ead335d76f61007b3f87d22ca396de4c281f386557%26token%3D1999792387%26lang%3Dzh_CN%23rd" class=" wrap external" target="_blank" rel="nofollow noreferrer">不小心，较真儿了：高德纳和特朗普</a> 谢谢大家指正。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="gFXHmhLp">6.</p>
 <p data-pid="qIX3kit2">对了，补充一下，我有两个学生，一个现在在网易游戏，一个现在在腾讯游戏，都表示在面试的时候遇到过这个问题（或者需要使用这个算法解决的问题）。</p>
 <p data-pid="1VP3Pfwp">腾讯游戏的大佬当时没有答上来；</p>
 <p data-pid="ohkCyjSX">网易游戏的大佬见过这个算法，虽然没有理解为什么，但说出来了。</p>
 <p data-pid="aYe1FSw9">因为游戏领域对随机算法的应用较多。</p>
 <p data-pid="-8a51OTQ">当然了，网易游戏或者腾讯游戏这种小地方，是不会入知乎上很多大佬的法眼的，面试竟然问这种问题？简直了。</p>
 <p data-pid="onR4Tnrl">补充：一名硅谷 Google 大佬表示 Google 面试叶问这个问题。</p>
 <hr>
 <p data-pid="uf2lfk3s">算法学习入门推荐《算法图解》：</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1258800133497266176"></a>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Gys2ZTYT">科班同学或者深入学习，吐血推荐一定要通读《算法4》</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1258800418479284224"></a>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="V7khNWvN">这本书英文版都值得收藏！</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1258800553851031552"></a>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="XS-nlq68">玩儿竞赛的同学，把刘汝佳的书啃了，就稳了。</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1258801174666121216"></a>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="booqpEDN">最后，欢迎大家关注我的<b>公众号【是不是很酷】（公众号id: isnt_<i>it_</i>cool）</b></p>
 <figure data-size="normal">
  <img src="https://picx.zhimg.com/50/v2-7e4e7ca1ff37cd1968a51bbd8b20e92e_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="500" data-original-token="v2-d65e940528a96fe5686fbd18729a148d" data-default-watermark-src="https://pic1.zhimg.com/50/v2-4d8dfc491fb6e2c6d79621209861486f_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1000" data-original="https://picx.zhimg.com/v2-7e4e7ca1ff37cd1968a51bbd8b20e92e_r.jpg?source=1940ef5c">
 </figure>
 <p></p>
</body>