# 如何理解关系型数据库的常见设计范式？
- 点赞数：9778
- 更新时间：2017年10月26日22时32分26秒
- 回答url：https://www.zhihu.com/question/24696366/answer/29189700
<body>
 <p data-pid="fn6tlLcD">2015-1-9 更新，回答了 <a class="member_mention" href="https://www.zhihu.com/people/7f66ba23ec1530541282a6979993afa5" data-hash="7f66ba23ec1530541282a6979993afa5" data-hovercard="p$b$7f66ba23ec1530541282a6979993afa5">@李德竹</a> 的问题<br>
  ============<br>
  2015-1-6 更新，补充了 BCNF 的解释<br>
  ============<br>
  国内绝大多数院校用的王珊的《数据库系统概论》这本教材，某些方面并没有给出很详细很明确的解释，与实际应用联系不那么紧密，你有这样的疑问也是挺正常的。我教《数据库原理》这门课有几年了，有很多学生提出了和你一样的问题，试着给你解释一下吧。（基本来自于我上课的内容，某些地方为了不过于啰嗦，放弃了一定的严谨，主要是在“关系”和“表”上）</p>
 <p data-pid="bVjM0IFc">首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为<b>一张数据表的表结构所符合的某种设计标准的级别</b>。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p>
 <p data-pid="cf1MdMha">接下来就对每一级范式进行一下解释，首先是<b>第一范式（1NF）。</b></p>
 <p data-pid="K79rnSNw">符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<b>1NF的定义为：符合1NF的关系中的每个属性都不可再分。表1</b>所示的情况，就不符合1NF的要求。</p>
 <figure>
  <img src="https://pica.zhimg.com/50/24afd11455ac34a280fa83e4e8d75ccc_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="743" data-rawheight="157" data-original-token="24afd11455ac34a280fa83e4e8d75ccc" class="origin_image zh-lightbox-thumb" width="743" data-original="https://picx.zhimg.com/24afd11455ac34a280fa83e4e8d75ccc_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="jVoOwnyt">表1</p>
 <p data-pid="PoLL-QpT">实际上，<b>1NF是所有关系型数据库的最基本要求</b>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为<b>表2</b>的形式：</p>
 <figure>
  <img src="https://picx.zhimg.com/50/6b735fb9503b0930e741faa474fed28e_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="881" data-rawheight="136" data-original-token="6b735fb9503b0930e741faa474fed28e" class="origin_image zh-lightbox-thumb" width="881" data-original="https://picx.zhimg.com/6b735fb9503b0930e741faa474fed28e_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="YjRHPtb9">表2</p>
 <p data-pid="5I9k8QDz">但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于<b>表3</b>中的设计：</p>
 <figure>
  <img src="https://picx.zhimg.com/50/5b16f655b57a957bfa340d0a996a0eea_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="661" data-rawheight="349" data-original-token="5b16f655b57a957bfa340d0a996a0eea" class="origin_image zh-lightbox-thumb" width="661" data-original="https://picx.zhimg.com/5b16f655b57a957bfa340d0a996a0eea_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="l7oS0xUw">表3</p>
 <ol>
  <li data-pid="-Jextkj6">每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<b>数据冗余过大</b></li>
  <li data-pid="3yRCC6VQ">假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——<b>插入异常</b><br><br>
   注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。<br><br>
   注２：<b>码：关系中的某个属性或者某几个属性的组合，用于区分每个元组</b>（可以把“元组”理解为一张表中的每条记录，也就是每一行）<b>。</b></li>
  <li data-pid="AROMxy1l">假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<b>删除异常</b></li>
  <li data-pid="z8Jal1yg">假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<b>修改异常</b>。</li>
 </ol>
 <p data-pid="nvoIYGFk">正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p>
 <p data-pid="N4Rgf02a"><b>第二范式（2NF）</b>在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，<b>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</b>。接下来对这句话中涉及到的四个概念——<b>“函数依赖”</b>、<b>“码”</b>、<b>“非主属性”</b>、与<b>“部分函数依赖”</b>进行一下解释。</p>
 <p data-pid="I1-sQAxD"><b>函数依赖</b><br>
  我们可以这么理解（但并不是特别严格的定义）：<b>若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y</b>。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。</p>
 <p data-pid="03zMDNHp">例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说<b>姓名函数依赖于学号</b>，写作 <b>学号 → 姓名</b>。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：</p>
 <ul>
  <li data-pid="R53_u20p">系名 → 系主任</li>
  <li data-pid="ad2Oxi60">学号 → 系主任</li>
  <li data-pid="zrAAfbDS">（学号，课名） → 分数</li>
 </ul>
 <p data-pid="i4t5kcia">但以下函数依赖关系则不成立：</p>
 <ul>
  <li data-pid="ZGwIu3iO">学号 → 课名</li>
  <li data-pid="9NQBWOfw">学号 → 分数</li>
  <li data-pid="eBgcANQb">课名 → 系主任</li>
  <li data-pid="1gFfk0th">（学号，课名） → 姓名</li>
 </ul>
 <p data-pid="PSTKkTv-">从“函数依赖”这个概念展开，还会有三个概念：</p>
 <p data-pid="p1yibb77"><b>完全函数依赖</b></p>
 <p data-pid="vH0LKANr">在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X <b>完全函数依赖</b>，记作 X F→ Y。（那个F应该写在箭头的正上方，没办法打出来……，正确的写法如<b>图1</b>）</p>
 <figure>
  <img src="https://picx.zhimg.com/50/12513de20079d12b99d946072df7311a_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="98" data-rawheight="53" data-original-token="12513de20079d12b99d946072df7311a" class="content_image" width="98">
 </figure>
 <p data-pid="QszdOtHa">图1</p>
 <p data-pid="fIoJio-w">例如：</p>
 <ul>
  <li data-pid="Hi2DJ90k">学号 F→ 姓名 <br></li>
  <li data-pid="RNp0wg7F">（学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</li>
 </ul>
 <p data-pid="mTRfyjZA"><b>部分函数依赖</b></p>
 <p data-pid="WOd1D8Pv">假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y，如<b>图2</b>。</p>
 <figure>
  <img src="https://pica.zhimg.com/50/10b52b39b18b8ea9fb17b46babf4d20f_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="99" data-rawheight="62" data-original-token="10b52b39b18b8ea9fb17b46babf4d20f" class="content_image" width="99">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="wBUNWdbo">图2</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="JG9CKEvw">例如：</p>
 <ul>
  <li data-pid="EHoqPp5Z">（学号，课名） P→ 姓名</li>
 </ul>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="JK5g4rQV"><b>传递函数依赖</b><br>
  假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （感谢 <a class="member_mention" href="https://www.zhihu.com/people/cd70559bf6f5073e39a22d98a805f3b6" data-hash="cd70559bf6f5073e39a22d98a805f3b6" data-hovercard="p$b$cd70559bf6f5073e39a22d98a805f3b6">@百达</a> 指出的错误，这里改为：『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，如<b>图3</b>。</p>
 <figure>
  <img src="https://pic1.zhimg.com/50/51f8105fbbe92adaa3e343ea2db3bf49_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="124" data-rawheight="77" data-original-token="51f8105fbbe92adaa3e343ea2db3bf49" class="content_image" width="124">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="RbfFiFvI">图3</p>
 <p data-pid="pESwcNeC"><b>码</b><br>
  设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为<b>候选码</b>，简称为<b>码</b>。在实际中我们通常可以理解为：<b>假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。</b>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为<b>主码</b>）</p>
 <p data-pid="PmOa0cgE">例如：<br>
  对于表3，<b>（学号、课名）</b>这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p>
 <p data-pid="ur_MOmtd"><b>非主属性</b><br>
  包含在任何一个码中的属性成为主属性。</p>
 <p data-pid="t6cUwxoO">例如：<br>
  对于表3，主属性就有两个，<b>学号</b> 与 <b>课名</b>。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="rI0R_jYw">终于可以回过来看2NF了。首先，我们需要判断，表3是否符合2NF的要求？根据2NF的定义，判断的依据实际上就是看数据表中<b>是否存在非主属性对于码的部分函数依赖</b>。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：</p>
 <p data-pid="KeakNb6_">第一步：找出数据表中所有的<b>码</b>。<br>
  第二步：根据第一步所得到的码，找出所有的<b>主属性</b>。<br>
  第三步：数据表中，除去所有的主属性，剩下的就都是<b>非主属性</b>了。<br>
  第四步：查看是否存在非主属性对码的<b>部分函数依赖</b>。</p>
 <p data-pid="o__DY4Y9">对于表3，根据前面所说的四步，我们可以这么做：</p>
 <p data-pid="z-yapQP_">第一步：</p>
 <ol>
  <li data-pid="c_jO5TUW">查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。</li>
  <li data-pid="Xsouf4Gw">查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。</li>
  <li data-pid="cpx7pOMa">……</li>
  <li data-pid="Uqk0rVrA">查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。</li>
 </ol>
 <p data-pid="2LBEpzRx">看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“<b>完全</b>函数依赖”）。</p>
 <p data-pid="UV0wyrvI"><b>图4</b>表示了表中所有的函数依赖关系：</p>
 <figure>
  <img src="https://picx.zhimg.com/50/51e2689ac9416a91800e63101bee9db7_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="541" data-rawheight="212" data-original-token="51e2689ac9416a91800e63101bee9db7" class="origin_image zh-lightbox-thumb" width="541" data-original="https://picx.zhimg.com/51e2689ac9416a91800e63101bee9db7_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="mOd5OYlg">图4</p>
 <p data-pid="PhX4rfej">这一步完成以后，可以得到，表3的码只有一个，就是<b>（学号、课名）</b>。</p>
 <p data-pid="Gtg8t38e">第二步：<br>
  主属性有两个：<b>学号 </b>与<b> 课名</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="atD2fr-f">第三步：<br>
  非主属性有四个：<b>姓名</b>、<b>系名</b>、<b>系主任</b>、<b>分数</b></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="E573AKOu"><b>第四步：</b><br>
  对于<b>（学号，课名） → 姓名</b>，有 <b>学号 → 姓名</b>，存在非主属性 <b>姓名 </b>对码<b>（学号，课名）</b>的部分函数依赖。<br>
  对于<b>（学号，课名） → 系名</b>，有 <b>学号 → 系名</b>，存在非主属性 系<b>名 </b>对码<b>（学号，课名）</b>的部分函数依赖。<br>
  对于<b>（学号，课名） → 系主任</b>，有 <b>学号 → 系主任</b>，存在非主属性 对码<b>（学号，课名）</b>的部分函数依赖。</p>
 <p data-pid="2R2oA0zQ">所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="8IGh2v7N">为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：<br>
  选课（学号，课名，分数）<br>
  学生（学号，姓名，系名，系主任）</p>
 <p data-pid="vDxKMaek">我们先来判断以下，<b>选课</b>表与<b>学生</b>表，是否符合了2NF的要求？</p>
 <p data-pid="I0Y-RR3V">对于<b>选课</b>表，其码是<b>（学号，课名）</b>，主属性是<b>学号</b>和<b>课名</b>，非主属性是<b>分数</b>，<b>学号</b>确定，并不能唯一确定<b>分数</b>，<b>课名</b>确定，也不能唯一确定<b>分数</b>，所以不存在非主属性<b>分数</b>对于码 <b>（学号，课名）</b>的部分函数依赖，所以此表符合2NF的要求。</p>
 <p data-pid="1EdY98AJ">对于<b>学生</b>表，其码是<b>学号，</b>主属性是<b>学号</b>，非主属性是<b>姓名、系名</b>和<b>系主任</b>，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。</p>
 <p data-pid="mweRQb-w"><b>图5</b>表示了模式分解以后的新的函数依赖关系</p>
 <figure>
  <img src="https://pic1.zhimg.com/50/2f4b4a887f6a61674a49d03d79e3fe17_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="961" data-rawheight="467" data-original-token="2f4b4a887f6a61674a49d03d79e3fe17" class="origin_image zh-lightbox-thumb" width="961" data-original="https://pica.zhimg.com/2f4b4a887f6a61674a49d03d79e3fe17_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="R2frfpWO">图5</p>
 <p data-pid="7SxPm-U-">表4表示了模式分解以后新的数据</p>
 <figure>
  <img src="https://picx.zhimg.com/50/44af74509a4e21372ed372be8560539d_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="478" data-rawheight="314" data-original-token="44af74509a4e21372ed372be8560539d" class="origin_image zh-lightbox-thumb" width="478" data-original="https://picx.zhimg.com/44af74509a4e21372ed372be8560539d_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Wijf4ZXz">表4</p>
 <p data-pid="s5YE4bpB">（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）</p>
 <p data-pid="BC_ikE8X">现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p>
 <ol>
  <li data-pid="UCgZUJA0">李小明转系到法律系<br>
   只需要修改一次李小明对应的系的值即可。——有改进</li>
  <li data-pid="lhs4TSH1">数据冗余是否减少了？<br>
   学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
  <li data-pid="UDjTde1N">删除某个系中所有的学生记录<br>
   该系的信息仍然全部丢失。——无改进</li>
  <li data-pid="M8MP6Jvg">插入一个尚无学生的新系的信息。<br>
   因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
 </ol>
 <p data-pid="_PhbUFy6">所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<b>系主任</b>对于码<b>学号</b>的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p>
 <p data-pid="ahy3U5Mx"><b>第三范式（3NF）</b> <b>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</b>。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p>
 <p data-pid="ryeLrn1Z">接下来我们看看表4中的设计，是否符合3NF的要求。</p>
 <p data-pid="o9bNAYj5">对于<b>选课</b>表，主码为（学号，课名），主属性为<b>学号</b>和<b>课名，</b>非主属性只有一个，为分数，不可能存在传递函数依赖，所以<b>选课</b>表的设计，符合3NF的要求。</p>
 <p data-pid="kv2CB8lX">对于<b>学生</b>表，主码为<b>学号</b>，主属性为<b>学号</b>，非主属性为<b>姓名</b>、<b>系名</b>和<b>系主任</b>。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性<b>系主任</b>对于码<b>学号</b>的传递函数依赖，所以<b>学生</b>表的设计，不符合3NF的要求。。</p>
 <p data-pid="sWWvvpWR">为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br>
  选课（学号，课名，分数）<br>
  学生（学号，姓名，系名）<br>
  系（系名，系主任）</p>
 <p data-pid="36w9ORP-">对于<b>选课</b>表，符合3NF的要求，之前已经分析过了。</p>
 <p data-pid="qTOqmrJc">对于<b>学生</b>表，码为<b>学号</b>，主属性为<b>学号</b>，非主属性为<b>系名</b>，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。</p>
 <p data-pid="oBNyu4CO">对于<b>系</b>表，码为<b>系名</b>，主属性为<b>系名</b>，非主属性为<b>系主任</b>，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="sXiaK3Dt">新的函数依赖关系如图6</p>
 <figure>
  <img src="https://picx.zhimg.com/50/5b20707ff3d9afb51ef7bfda726c3e34_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="783" data-rawheight="388" data-original-token="5b20707ff3d9afb51ef7bfda726c3e34" class="origin_image zh-lightbox-thumb" width="783" data-original="https://pic1.zhimg.com/5b20707ff3d9afb51ef7bfda726c3e34_r.jpg?source=1940ef5c">
 </figure>
 <p data-pid="g7tOlH0F">图6</p>
 <p data-pid="2OC6OHfH">新的数据表如表5</p>
 <figure>
  <img src="https://pica.zhimg.com/50/8bca802bcff92a8945bf808d18d7ec62_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="470" data-rawheight="419" data-original-token="8bca802bcff92a8945bf808d18d7ec62" class="origin_image zh-lightbox-thumb" width="470" data-original="https://picx.zhimg.com/8bca802bcff92a8945bf808d18d7ec62_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="Hhvf3dLH">表5</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="iMnO4bf4">现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p>
 <ol>
  <li data-pid="H7HVotgD">删除某个系中所有的学生记录<br>
   该系的信息不会丢失。——有改进</li>
  <li data-pid="zsvZVYRi">插入一个尚无学生的新系的信息。<br>
   因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
  <li data-pid="WXfzQxEY">数据冗余更加少了。——有改进</li>
 </ol>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="YabwDgms"><b>结论</b><br>
  由此可见，符合3NF要求的数据库设计，<b>基本</b>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p>
 <p data-pid="8wujLG0s">==============时隔半年，终于决定把这个坑填上，来晚了 ===========</p>
 <p data-pid="CWAFONac"><b>BCNF范式</b></p>
 <p data-pid="wdgyzvdv">要了解 BCNF 范式，那么先看这样一个问题：</p>
 <p data-pid="NfC0MF_u">若：</p>
 <ol>
  <li data-pid="v1cjRjMK">某公司有若干个仓库；<br></li>
  <li data-pid="mOxATuay">每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；<br></li>
  <li data-pid="wBoSgEMx">一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。<br></li>
 </ol>
 <p data-pid="aPb9RoqF">那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
 <p data-pid="pT7Pm849">答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>
  码：（管理员，物品名），（仓库名，物品名）<br>
  主属性：仓库名、管理员、物品名<br>
  非主属性：数量<br>
  ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
 <p data-pid="Exsav0fp">基于此关系模式的关系（具体的数据）可能如图所示：</p>
 <figure>
  <img src="https://picx.zhimg.com/50/68d080d437732aad8cfe451b427849d6_720w.jpg?source=1940ef5c" data-caption="" data-rawwidth="625" data-rawheight="296" data-original-token="68d080d437732aad8cfe451b427849d6" class="origin_image zh-lightbox-thumb" width="625" data-original="https://picx.zhimg.com/68d080d437732aad8cfe451b427849d6_r.jpg?source=1940ef5c">
 </figure>
 <p class="ztext-empty-paragraph"><br></p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="iUxN2Ah3">好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
 <ol>
  <li data-pid="NE7VU5Ak">先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
  <li data-pid="zYWe4ksS">某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。<br></li>
  <li data-pid="P6f1GZ6L">如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。<br></li>
 </ol>
 <p data-pid="1yuw9m49">从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
 <p data-pid="GaBXn9xa">造成此问题的原因：存在着<b>主属性</b>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
 <p data-pid="lF-aL3Ab">解决办法就是要在 3NF 的基础上消除<b>主属性</b>对于码的部分与传递函数依赖。</p>
 <p data-pid="xzz5mD-h">仓库（仓库名，管理员）<br>
  库存（仓库名，物品名，数量）</p>
 <p data-pid="Psb0jBTE">这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
 <p data-pid="KdwtQRfG">以上就是关于 BCNF 的解释。</p>
 <p class="ztext-empty-paragraph"><br></p>
 <p data-pid="d9iyyk7f">最近身体不太舒服，写不动了。有空再放几个典型习题及其解答吧。<br>
  ===============================<br>
  问题1：</p>
 <p data-pid="stbs2-yt"><a href="http://www.zhihu.com/people/li-de-zhu-84" class="internal">李德竹</a> ：老师您好，我看了您关于数据库范式的回答，有一点不太理解，就是关于码的定义，如果除K之外的所有属性都完全函数依赖于K时才能称K为码，那么在判断2NF时又怎么会存在非主属性对码的部分函数依赖这种情况？希望老师有时间能指点一下，谢谢</p>
 <p data-pid="qn5BTlWF">我 ：在“码”的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。</p>
 <p data-pid="cPB_9ICA">比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F= {<br>
  Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }</p>
 <p data-pid="VFjgCC1t">那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno / Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。</p>
 <p data-pid="jm3QCuUj">所以可得到主属性：Sno, Cno<br>
  非主属性：Sname, Cname, Sdept, Sloc, Grade</p>
 <p data-pid="dpU41YU4">R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。</p>
 <p data-pid="uPkxh7D3">========================================</p>
 <p data-pid="5bGuwQ7j">花了好几天断断续续写了这个答案，累死我了。看有不少人对此有疑问，干脆写一个详细点的，希望成为这个知识点的权威回答……如果有一些细节方面的问题，比如表达上，还会进行修改，大的方面，肯定是没错的。</p>
</body>